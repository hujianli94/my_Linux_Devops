.. contents::
   :depth: 3
..

01.轻量级HTTP服务器Nginx
========================

作为一个轻量级的HTTP服务器，Nginx与Apache相比有以下优势：在性能上，它占用很少的系统资源，能支持更多的并发连接，达到更高的访问效率；在功能上，Nginx是优秀的代理服务器和负载均衡服务器；在安装配置上，Nginx安装简单、配置灵活。下面就详细介绍Nginx的配置与使用。

Nginx与Apache的异同
-------------------

Nginx和Apache一样，都是HTTP服务器软件，在功能实现上都采用模块化结构设计，都支持通用的语言接口，如PHP、Perl、Python等，同时还支持正向和反向代理、虚拟主机、URL重写、压缩传输、SSL加密传输等。

它们之间最大的差别是：

-  Apache的处理速度很慢，且占用很多内存资源，而Nginx却恰恰相反；在功能实现上，Apache的所有模块都支持动、静态编译，而Nginx模块都是静态编译的
-  同时，Apache对Fcgi的支持不好，而Nginx对Fcgi的支持非常好；
-  在处理连接方式上，Nginx支持epoll，而Apache却不支持；
-  在空间使用上，Nginx安装包仅仅只有几百K，和Nginx比起来Apache绝对是庞然大物。

在了解了Nginx和Apache之间的异同点后基本上就知道了Nginx作为HTTP服务器的优势所在。

Nginx的优势所在
---------------

-  作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高。

-  作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度。

-  作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡。
   在性能方面，Nginx是专门为性能优化而开发的，在实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对50000个并发连接数的响应，而且只占用很低的内存资源。

-  在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持10000个没有活动的连接，而这些连接只占用
   2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的。

-  在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以
   做到7×24小时不间断地运行。

Nginx的模块与工作原理
---------------------

Nginx由内核和模块组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location
block(location
是Nginx配置中的一个指令，用于URL匹配)，而在这个location中所配置的每个指
令将会启动不同的模块去完成相应的工作。

Nginx的模块从结构上分为\ ``核心模块``\ 、\ ``基础模块``\ 和\ ``第三方模块``\ ，

::

   HTTP模块、EVENT模块和MAIL模块等属于核心模块，

   HTTP Access模块、HTTP FastCGI模块、HTTPProxy模块和HTTP Rewrite模块属于基础模块，

   而HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块属于第三方模块，

用户根据自己的需要开发的模块都属于第三方模块。正是有了这么多模块的支撑，Nginx的功能才会如此
强大。

Nginx的模块从功能上分为如下三类。

::

   Handlers(处理器模块)。此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个。

   Filters(过滤器模块)。此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。

   Proxies(代理类模块)。此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能

Nginx模块常规的HTTP请求和响应的过程如下图所示：

.. image:: ../../_static/nginx00001.PNG

在工作方式上，Nginx分为\ ``单工作进程``\ 和\ ``多工作进程``\ 两种模式。

::

   在单工作进程模式下，除主进程外，还有一个工作进程，工作进程是单线程的；

   在多工作进程模式下，每个工作进程包含多个线程。

Nginx默认为单工作进程模式。Nginx的模块直接被编译进Nginx，因此属于静态编译方式。启动Nginx后，Nginx
的模块被自动加载，不像Apache，首先将模块编译为一个so文件，然后在配置文件中指定是否进行加载。在解析配置文件时，Nginx的每个模块都有可能去处理某个请
求，但是同一个处理请求只能由一个模块来完成。

Nginx的安装与配置
-----------------

Nginx的官方网站是http://sysoev.ru/nginx/，英文主页为http://nginx.net，从这里可以获得Nginx的最新版本信息。

Nginx有三个版本：
稳定版、开发版和历史稳定版。开发版更新较快，包含最新的功能和bug的修复，但
同时也可能会出现新的bug。开发版一旦更新稳定下来，就会被加入稳定版分支中。
然而有些新功能不一定会被加到稳定版中去。稳定版更新较慢，但是bug较少，可以作为生产环境的首选，因此通常建议使用稳定版。历史稳定版为以往稳定版本的汇总，不包含最新的功能。

这里选择当前的稳定版本nginx-0.7.65作为介绍对象，开始介绍编译安装。

在安装Nginx之前，确保系统已经安装了gcc、openssl-devel、pcre-devel和zlib-devel软件库。

Linux开发库是在安装系统时通过手动选择安装的，gcc、openssl-devel、zlib-
devel三个软件库可以通过安装光盘直接选择安装，而pcre-devel库默认不在系统
光盘中，所以这里重点介绍pcre-devel库。

1.安装Nginx所需的pcre-devel库
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

   #安装pcre库是为了使Nginx支持HTTP Rewrite模块。下面进行安装，过程如下：
   [root@localhost home]#tar zxvf pcre-8.02.tar.gz
   [root@localhost home]#cd pcre-8.02
   [root@localhost pcre-8.02]#make
   [root@localhost pcre-8.02]#make install

2.开始安装Nginx
~~~~~~~~~~~~~~~

Nginx的安装非常简单。在默认情况下，经过编译安装的Nginx包含了大部分可用模块。

可以通过\ ``“./configure--help”``\ 选项设置各个模块的使用情况，例如对不需要的http_ssi模块，可通过\ ``“--without-http_ssi_module”``\ 方式关闭此。

同理，如果需要“http_perl”模块，那么可以通过\ ``“--with-http_perl_module”``\ 方式进行安装。

下面是安装过程：

::

   [root@localhosthome]#tar zxvf nginx-0.7.65.tar.gz
   [root@localhost home]#cd nginx-0.7.65
   [root@localhostnginx-0.7.65]#./configure\
   --with-http_stub_status_module --prefix=/usr/local/nginx

   [root@localhost nginx-0.7.65]#make

   [root@localhost nginx-0.7.65]#make install

   在上面的configure选项中，“--with-http_stub_status_module”可以用来启用Nginx的NginxStatus功能，以监控Nginx的当前状态。

至此，Nginx已经安装完成了。

Nginx配置文件的结构
-------------------

Nginx的配置文件是一个纯文本文件，它一般位于Nginx安装目录的conf目录下，整个配置文件是以block的形式组织的。每个block一般以一个大括号“{}”来表示，
block可以分为几个层次，整个配置文件中main指令位于最高层，在main层下面可以有Events、HTTP等层级，而在HTTP层中又包含有server层，即server
block,server block中又可分为location层，并且一个server
block中可以包含多个location block。

一个完整的配置文件结构如图:

Nginx配置文件结构

.. image:: ../../_static/nginx000001.png

一个完整的Nginx配置文件结构如下：

::

   main
   events {
       ....
   }
   http {
       ....
       upstream project_name {
       ....
       }
       server {
       ....
       location {
           ....
       }
       
       include /path/of/nginx/conf.d/*.conf
       }
       ....
   }

配置与调试Nginx
---------------

Nginx安装完毕后，会产生相应的安装目录，根据前面的安装路径，Nginx的配置文件路径为/opt/nginx/conf，其中nginx.conf为Nginx的主配置文件。这里重点介
绍nginx.conf这个配置文件。

Nginx配置文件主要分为4部分：

::

   main(全局设置)、
   server(主机设置)、
   upstream(负载均衡服务器设置)
   和location(URL匹配特定位置的设置)。

-  main部分设置的指令将影响其他所有设置；
-  server部分的指令主要用于指定主机和端口；
-  upstream指令主要用于负载均衡，设置一系列的后端服务器；
-  location部分用于匹配网页位置。

这四者之间的关系如下：

``server继承main,location继承server,upstream既不会继承其他设置也不会被继承。``

在这4个部分当中，每个部分都包含若干指令，这些指令主要包含Nginx的主模块指
令、事件模块指令、HTTP核心模块指令。同时每个部分还可以使用其他HTTP模块指令，例如Http
SSL模块、Http Gzip Static模块和Http Addition模块等。

1.Nginx的全局配置
~~~~~~~~~~~~~~~~~

::

   user nobody nobody；
   worker_processes4；

   error_log logs/error.log notice；
   pid logs/nginx.pid；

   worker_rlimit_nofile65535；

   events{
       use epoll；
       worker_connections65536；

   }

参数解释

::

   user是个主模块指令，指定Nginx Worker进程运行用户以及用户组，默认由
   nobody账号运行。

   worker_processes是个主模块指令，指定了Nginx要开启的进程数。每个Nginx进程平均耗费10MB～12MB内存。
   根据经验，一般指定一个进程足够了，如果是多核CPU，建议指定和CPU的数量一样多的进程数即可。

   error_log是个主模块指令，用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。


   pid是个主模块指令，用来指定进程id的存储文件位置。
   worker_rlimit_nofile用于绑定worker进程和CPU,Linux内核2.4以上可用。

   events指令用来设定Nginx的工作模式及连接数上限。


   use是个事件模块指令，用来指定Nginx的工作模式。Nginx支持的工作模式有
   select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中。对于Linux系统，epoll工作模式是首选。

   worker_connections也是个事件模块指令，用于定义Nginx每个进程的最大连接数，默认是1024。

   最大客户端连接数由worker_processes和worker_connections决定，即
   max_client=worker_processes*worker_connections，在作为反向代理时变为：max_clients=worker_processes*worker_connections/4。

   进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit-n65536”后worker_connections的设置才能生效。

2.HTTP服务器配置
~~~~~~~~~~~~~~~~

::

   http{
       include conf/mime.types；
       default_type application/octet-stream；
       log_format main'$remote_addr-$remote_user[$time_local]'
       '"$request"$status$bytes_sent'
       '"$http_referer""$http_user_agent"'
       '"$gzip_ratio"'；
       log_format download'$remote_addr-$remote_user[$time_local]'
           '"$request"$status$bytes_sent'
           '"$http_referer""$http_user_agent"'
           '"$http_range""$sent_http_content_range"'；
           client_max_body_size20m；
           client_header_buffer_size32k；
           large_client_header_buffers432k；
           sendfile on；
           tcp_nopush on；
           tcp_nodelay on；
           keepalive_timeout60；
           client_header_timeout10；
           client_body_timeout10；
           send_timeout10；
    }

3.HttpGzip模块配置
~~~~~~~~~~~~~~~~~~

下面配置Nginx的HttpGzip模块。这个模块支持在线实时压缩输出数据流。

要查看是否安装了此模块，需要使用下面的命令：

::

   [root@localhost conf]#/usr/local/nginx/sbin/nginx-V
   nginx version：nginx/0.7.65
   configure arguments：--with-http_stub_status_module --with-
   http_gzip_static_module --prefix=/opt/nginx

通过\ ``/usr/local/nginx/sbin/nginx-V``\ 命令可以查看安装Nginx时的编译选项。由输出可知，我们已经安装了HttpGzip模块。

下面是HttpGzip模块在Nginx配置中的相关属性设置：

::

   gzip on；
   gzip_min_length 1k；
   gzip_buffers 416k；
   gzip_http_version 1.1；
   gzip_comp_level 2；
   gzip_types text/plain application/x-javascript text/css
   application/xml；
   gzip_vary on；

参数解释

::

   gzip用于设置开启或者关闭gzip模块，“gzip on”表示开启gzip压缩，实时压缩输出数据流。

   gzip_min_length用于设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取。默认值是0，不管页面多大都进行压缩。
   建议设置成大于1K的字节数，小于1K可能会越压越大。

   gzip_buffers表示申请4个单位为16K的内存作为压缩结果流缓存，默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果。

   gzip_http_version用于设置识别HTTP协议版本，默认是1.1，目前大部分浏览器已经支持gzip解压，使用默认即可。

   gzip_comp_level用来指定gzip压缩比，1压缩比最小，处理速度最快；9压缩比最大，传输速度快，但处理最慢，也比较消耗CPU资源。

   gzip_types用来指定压缩的类型，无论是否指定，“text/html”类型总是会被压缩的。

   gzip_vary选项可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。

4.负载均衡配置
~~~~~~~~~~~~~~

下面设定负载均衡的服务器列表。

::

   upstream ixdba.net{
       ip_hash；
       server 192.168.12.133：80；
       server 192.168.12.134：80 down；
       server 192.168.12.135：8009 max_fails=3 fail_timeout=20s；
       server 192.168.12.136：8080；
   }

upstream是Nginx的HTTP
Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。

在上面的设定中，通过upstream指令指定了一个负载均衡器的名称ixdba.net。这个名称可以任意指定，在后面需要用到的地方直接调用即可。

Nginx的负载均衡模块目前支持4种调度算法，下面进行分别介绍，其中后两项属于第三方调度算法。

::

   轮询(默认)。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。

   Weight。指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。


   ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。


   fair。这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，
   响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。

   url_hash。此方法按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。
   Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx的hash软件包。


   在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，

   同时还可以设定每个后端服务器在负载均衡调度中的状态。

   常用的状态有：

   down，表示当前的server暂时不参与负载均衡。

   backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。

   max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream模块定义的错误。

   fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。

   注意 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup.

5.server虚拟主机配置
~~~~~~~~~~~~~~~~~~~~

下面介绍对虚拟主机的配置。建议将对虚拟主机进行配置的内容写进另外一个文件，然后通过include指令包含进来，这样更便于维护和管理。

::

   server{
       listen 80；
       server_name 192.168.12.188 www.ixdba.net；
       index index.html index.htm index.jsp；
       root /web/wwwroot/www.ixdba.net
       charset gb2312；
       access_log logs/www.ixdba.net.access.log main；

参数说明：

::

   server标志定义虚拟主机开始；
   listen用于指定虚拟主机的服务器端口；
   server_name用来指定IP地址或者域名，多个域名之间用空格分开；
   index用于设定访问的默认首页地址；
   root指令用于指定虚拟主机的网页根目录，这个目录可以是相对路径，也可以是绝对路径；
   charset用于设置网页的默认编码格式。
   access_log用来指定此虚拟主机的访问日志存放路径。最后的main用于指定访问日志的输出格式

6.URL匹配配置
~~~~~~~~~~~~~

URL地址匹配是Nginx配置中最灵活的部分。location支持正则表达式匹配，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页的过滤处理。

以下这段设置是通过location指令来对网页URL进行分析处理，所有扩展名为.gif、.jpg、.jpeg、.png、.bmp、.swf的静态文件都交给Nginx处理，而
expires用来指定静态文件的过期时间，这里是30天。

::

   location～.*\.(gif|jpg|jpeg|png|bmp|swf)${
       root/web/wwwroot/www.ixdba.net；
       expires 30d；
   }

以下这段设置是将upload和html下的所有文件都交给Nginx来处理，当然，upload
和html目录包含在\ ``/web/wwwroot/www.ixdba.net``\ 目录中。

::

   location～^/(upload|html)/{
   root/web/wwwroot/www.ixdba.net；
   expires 30d；
   }

在最后这段设置中，location是对此虚拟主机下动态网页的过滤处理，也就是将所
有以.jsp为后缀的文件都交给本机的8080端口处理。

::

   location～.*.jsp${
       index index.jsp；
       proxy_pass http://localhost:8080；
   }

7.StubStatus模块配置
~~~~~~~~~~~~~~~~~~~~

StubStatus模块能够获取Nginx自上次启动以来的工作状态，此模块非核心模块，
需要在Nginx编译安装时手工指定才能使用。

以下指令指定启用获取Nginx工作状态的功能。

::

   location/NginxStatus{
       stub_status on；
       access_log logs/NginxStatus.log；
       auth_basic  "NginxStatus"；
       auth_basic_user_file    ……/htpasswd；
   }

参数说明

::

   stub_status为“on”表示启用StubStatus的工作状态统计功能；
   access_log用来指定StubStatus模块的访问日志文件；
   auth_basic是Nginx的一种认证机制；
   auth_basic_user_file用来指定认证的密码文件。

由于Nginx的auth_basic认证采用的是与Apache兼容的密码文件，因此需要用Apache的htpasswd命令来生成密码文件。例如要添加一个webadmin用户，可以使用下面的方式生成密码文件：

::

   /usr/local/apache/bin/htpasswd-c/opt/nginx/conf/htpasswd webadmin

输入密码之后，系统会要求再次输入密码，确认之后添加用户成功。
要查看Nginx的运行状态，可以输入\ ``http//ip/NginxStatus``\ ，然后输入刚刚创建
的用户名和密码就可以看到如下信息：

::

   Active connections：1
   server accepts handled requests
   393411393411393799
   Reading：0Writing：1Waiting：0

Nginx的启动、关闭和平滑重启
---------------------------

在完成对nginx.conf文件的配置后，就可以启动服务了。

Nginx自身提供了一些用于日常维护的命令，下面进行详细的介绍。

1.Nginx基本信息检查

(1)检查Nginx配置文件的正确性

::

   /usr/local/nginx/sbin/nginx -t
   或者
   /usr/local/nginx/sbin/nginx -t -c   /usr/local/nginx/conf/nginx.conf

(2)显示Nginx的版本以及相关编译信息

::

   在命令行执行以下命令可以显示安装Nginx的版本信息：
   /usr/local/nginx/sbin/nginx -v

   执行以下命令可显示安装的Nginx版本和相关编译信息：
   /usr/local/nginx/sbin/nginx -V

2.Nginx的启动、关闭与重启
Nginx对进程的控制能力非常强大，可以通过信号指令控制进程。常用的信号有：

::

   QUIT，表示处理完当前请求后，关闭进程。

   HUP，表示重新加载配置，也就是关闭原有的进程，并开启新的工作进程。此操作不会中断用户的访问请求，因此可以通过此信号平滑地重启Nginx。

   USR1，用于Nginx的日志切换，也就是重新打开一个日志文件，例如每天要生成一个新的日志文件时，可以使用这个信号来控制。

   USR2，用于平滑升级可执行程序。

   WINCH，从容关闭工作进程。

(1)Nginx的启动

Nginx的启动非常简单，只需输入如下命令：

::

   /usr/local/nginx/sbin/nginx

   即可完成Nginx的启动。Nginx启动后，可以通过如下命令查看Nginx的启动进程：
   [root@localhost logs]#ps-ef|grep nginx

(2)Nginx的关闭

如果要关闭Nginx进程，可以使用如下命令：

::

   kill-XXX pid
   其中，XXX就是信号名，pid是Nginx的进程号，可以通过如下两个命令获取：

   ps-ef|grep"nginx：master process"|grep-v"grep"|awk-
   F'''{print$2}'

   cat/usr/local/nginx/logs/nginx.pid

(3)Nginx的平滑重启

要不间断服务地重新启动Nginx，可以使用如下命令：

::

   kill -HUP ‘/usr/local/nginx/logs/nginx.pid‘

Nginx常用配置实例
-----------------

1.虚拟主机配置实例
~~~~~~~~~~~~~~~~~~

下面在Nginx中创建3个虚拟主机，需要说明的是，这里仅仅列出了虚拟主机的配置
部分。

默认虚拟主机在\ ``/web/www/domain1.com/htdocs``\ 下

::

   http{
       server{
       listen 80；
       server_name www.domain1.com；            #网站域名
       access_log logs/domain1.access.log main；
       location/{
           index index.html；                   #指定索引页
           root /web/www/domain1.com/htdocs；   #指定网站路径
   }
   }
       server{
       listen 80；
       server_name www.domain2.com；
       access_log logs/domain2.access.log main；
       location/{
       index index.html；
       root /web/www/domain2.com/htdocs；
   }
   }
       include /opt/nginx/conf/vhosts/www.domain2.com.conf；
   }

这里用到了\ ``include指令``\ ，其中\ ``/opt/nginx/conf/vhosts/www.domain2.com.conf``\ 的内容如下：

::

   server{
       listen 80；
       server_name www.domain3.com；
       access_log logs/domain3.access.log main；
       location/{
       index index.html；
       root /web/www/domain3.com/htdocs；
   }
   }

2.Nginx用户认证
~~~~~~~~~~~~~~~

2.1 对整站进行用户认证
^^^^^^^^^^^^^^^^^^^^^^

创建一个虚拟主机配置文件，名称为\ ``bone.conf.conf``\ ，配置文件内容如下：

::

   server
   {
       # 默认配置文件代码
       
       listen 80;
       server_name humingzhe.cn;
       index index.htm index.html index.php;
       root /data/www/humingzhe.cn;
       
       
       location /
       {
           auth_basic "Auth";
           auth_basic_user_file /usr/local/nginx/conf/htpasswd;
       }
   }

Nginx用户认证需要用到Apache的密码生成文件，如果没有Apache，使用yum命令安装即可，操作命令如下：

.. code:: shell

   /usr/local/apache2.4/bin/htpasswd -c /usr/local/nginx/conf/htpasswd bone

   cat /usr/local/nginx/conf/htpasswd

使用curl命令测试nginx用户认证功能，操作命令如下：

.. code:: shell

   curl -ubone:xxxx -x127.0.0.1:80 humingzhe.cn

2.2 对某目录做用户认证
^^^^^^^^^^^^^^^^^^^^^^

针对某个目录做用户认证，如针对admin目录做用户认证。只需要把bone.conf.conf配置文件中的\ ``location /``
改为\ ``location /admin/``\ 即可。

::

       # 对某目录做用户认证
       location /admin/
       {
           auth_basic "Auth";
           auth_basic_user_file /usr/local/nginx/conf/htpasswd;
       }

.. code:: shell

   curl -ubone:xxxx -x127.0.0.1:80 humingzhe.cn/admin/

2.3 对某文件做用户认证
^^^^^^^^^^^^^^^^^^^^^^

::

       # 对某文件做用户认证
       location ~ admin.php
       {
           auth_basic "Auth";
           auth_basic_user_file /usr/local/nginx/conf/htpasswd;
       }

.. code:: shell

   curl -ubone:xxxx -x127.0.0.1:80 humingzhe.cn/admin.php

3.Nginx域名跳转
~~~~~~~~~~~~~~~

::

   # Nginx域名跳转

       listen 80;
       server_name humingzhe.cn www.humingzhe.com;
       index index.htm index.html index.php;
       root /data/www/humingzhe.cn;
       if ($host != 'humingzhe.cn' ){
           rewrite ^/(.*)$ http://humingzhe.cn/$1 permanent;
       }

使用curl访问\ ``www.humingzhe.com``\ 时会自动显示301状态码，并告知location是humingzhe.cn。

4.Nginx访问日志
~~~~~~~~~~~~~~~

Nginx主配置文件\ ``nginx.conf``\ 中有一段代码是
log_format,log_format是定义Nginx访问日志的格式，代码和格式含义如下：

::

   log_format combined_realip '$remote_addr $http_x_forwarded_for [$time_local]'
       ' $host "$request_uri" $status'
       ' "$http_referer" "$http_user_agent"';

::

   $remote_addr : 客户端IP(公网IP)
   $http_x_forwarded_for：代理服务器IP
   $time_local：服务器本地时间
    $host：访问主机名（域名）
   $request_uri：访问的url地址
   $status：状态码
   $http_referer：每个页面的引用记录、页面统计
   $http_user_agent：用户代理

配置文件定义完日志格式后，还需要在虚拟主机配置文件中添加代码，代码如下：

::

   server
   {
       # 记录日志  
       access_log /data/logs/nginx/humingzhe.com.log mingzhe;
   }

5.Nginx日志切割配置实例
~~~~~~~~~~~~~~~~~~~~~~~

Nginx没有类似Apache的cronolog日志分割处理的功能，但是，可以通过Nginx的
信号控制功能的脚本来实现日志的自动切割。请看下面的一个实例。

Nginx对日志进行处理的脚本

5.1配置示例1
^^^^^^^^^^^^

``cut_nginx_log.sh``

.. code:: shell

   #/bin/bash
   savepath_log='/home/nginx/logs'     #指定分割后的日志存放的路径
   nglogs='/opt/nginx/logs'        #指定分割后的日志存放的路径，

   mkdir -p $savepath_log/$(date+%Y)/$(date+%m)
   mv $nglogs/access.log $savepath_log/$(date+%Y)/$(date+%m)/access.$(date+%Y%m%d).log
   mv $nglogs/error.log $savepath_log/$(date+%Y)/$(date+%m)/error.$(date+%Y%m%d).log
   #通过Nginx的信号“USR1”实现了日志的自动切换功能。
   kill -USR1 cat/opt/nginx/logs/nginx.pid

5.2配置示例2
^^^^^^^^^^^^

``nginx_logrotate.sh``

.. code:: shell

   #!/bin/bash
   ##定义 Nginx 日志路径为/data/logs/nginx/
   ##email admin@humingzhe.com

   # Nginx日志切割
   d=`date -d "-1 day" +%Y%m%d `
   logdir="/data/logs/nginx/"
   nginx_pid="/usr/local/nginx/logs/nginx.pid"
   cd $logdir
   for log in `ls *.log`
   do
       mv $log $d-$log
   done
   /bin/kill -HUP `cat $nginx_pid`

脚本添加完毕后，执行该日志脚本使用\ ``-x``\ 选项查看脚本文件的执行过程，操作命令如下：

.. code:: shell

   sh -x /usr/local/sbin/nginx_logrotate.sh

确保日志切割完毕后，可以加入到计划任务中。

将这段脚本保存后加入到Linux的crontab守护进程，让此脚本在每天凌晨0点执行，就可以实现日志的每天分割功能了。

``crontab -e``

.. code:: shell

   00 00 * * * /bin/bash /usr/local/webserver/nginx/sbin/cut_nginx_log.sh

6.静态文件不记录日期和时间
~~~~~~~~~~~~~~~~~~~~~~~~~~

Nginx也可以像Apache一样不记录静态文件的日期和时间，编辑虚拟主机配置文件即可，在配置文件中添加如下代码。

``vim /usr/local/nginx/conf/vhost/mingzhe.com.conf``

::

   server {
       # 静态文件不记录日期和时间
       location ~ .*\.(gif|jpg|jpeg|png|txt|doc|docx|swf)${
           expires 7d;
           access_log off;
       }
       location ~ .*\.(js|css)${
           expires 12h;
           access_log off;
       }
   }

7.Nginx设置防盗链
~~~~~~~~~~~~~~~~~

Nginx和Apache一样，也可以设置防盗链，编辑Nginx虚拟主机配置文件，在配置文件中增加如下代码。

``vim /usr/local/nginx/conf/vhost/mingzhe.com.conf``

::

   server{
       # 配置防盗链
       location ~ .*\.(gif|jpg|jpeg|png|txt|doc|docx|swf|flv|rar|zip|gz|bz2|pdf|xls)$ {
           expires 7d;
           valid_referers none blocked server_name *.mingzhe.com ;
           if ($invalid_referer) {
               return 403;
           }
           access_log off;
       }
   }

8.Nginx进行访问控制
~~~~~~~~~~~~~~~~~~~

``vim /usr/local/nginx/conf/vhost/mingzhe.com.conf``

针对/admin/目录做访问控制，只允许指定的IP访问/admin/目录，设置代码如下：

::

   server{
       # Nginx IP 访问控制
       location /admin/
       {
           allow 127.0.0.1;
           allow 192.168.222.129;
           deny all;
       }
   }   

Nginx可以匹配正则表达式进行访问控制，代码如下：

::

       # Nginx正则表达式访问控制
   server{
       location ~ .*(upload|image)/.*\.php$
       {
           deny all;
       }
   }

Nginx可以针对user_agent进行限制，代码如下。

::

   server {
       # 对user_agent进行限制
       if ($http_user_agent ~ 'Spider/3.0|YoudaoBot|Tomtato'){
           return 403;
       }
   }

9.Nginx解析PHP相关设置
~~~~~~~~~~~~~~~~~~~~~~

虽然在mingzhe.com.conf配置文件中做了很多相关设置，但还是不能进行PHP解析操作，需要继续编辑mingzhe.com.conf配置文件，增加如下代码。

``vim /usr/local/nginx/conf/vhost/mingzhe.com.conf``

::

   server{
       # 解析PHP相关配置
       location ~ \.php${
           include fastcgi_params;
           fastcgi_pass unix:/tmp/php-fcgi.sock;
           fastcgi_index index.php;
           fastcgi_param SCRIPT_FILENAME
           /data/www/default$fastcgi_script_name;
       }
   }

代码添加完毕后需要重载配置文件，就能正常解析PHP代码。

10.Nginx代理
~~~~~~~~~~~~

Nginx反向代理，通过一台服务器作为入口，访问后端某一台Web服务器，进行用户数据的转发。

``vim /opt/nginx/conf/nginx.conf``

::

   application/xml;
   incloud vhost/*.conf;

使用Nginx代理功能需要在vhost目录下创建一个新的配置文件，如\ ``proxy.conf``\ ，在该配置文件中增加如下代码。

``vim /opt/nginx/conf/vhost/proxy.conf``

::

   server {
       # Nginx代理
       listen 80;
       server_name www.baidu.com;
       
       location /{
           proxy_pass http://61.135.163.121/;
           proxy_set_header HOST $host;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For
           $proxy_add_x_forwarded_for;
       }
   }

11.负载均衡配置实例
~~~~~~~~~~~~~~~~~~~

代理一台服务器称作代理
，代理两台或两台以上的服务器称为负载均衡。代理服务器后面可以是多台Web服务器，多台Web服务器提供服务时即可实现负载均衡的功能。Nginx负载均衡借助upstream模块，在proxy_pass处不能定义多个IP，但在upstream下面可以定义多个IP。

下面\ **通过Nginx的反向代理功能配置一个Nginx负载均衡服务器**\ 。后端有3个服务节
点，用于提供Web服务，通过Nginx的调度实现3个节点的负载均衡。

11.1 配置示例
^^^^^^^^^^^^^

::

   http{
       upstream myserver{
       server 192.168.12.181：80 weight=3 max_fails=3 fail_timeout=20s；
       server 192.168.12.182：80 weight=1 max_fails=3 fail_timeout=20s；
       server 192.168.12.183：80 weight=4 max_fails=3 fail_timeout=20s；
       }
       
       server{
       listen 80；
       server_name www.domain.com 192.168.12.189；
       index index.htm index.html；
       root /ixdba/web/wwwroot；
       
       location /{
           proxy_pass http://myserver；
           proxy_next_upstream http_500 http_502 http_503 error timeout invalid_header；
           include /opt/nginx/conf/proxy.conf；
       }
   }

在上面这个配置实例中，\ **先定义了一个负载均衡组myserver，然后在location部**
**分通过“proxy_pass http://myserver”实现负载调度功能，**
**其中proxy_pass指令用来指定代理的后端服务器地址和端口，地址可以是主机名或者IP地址，也可以是通过upstream指令设定的负载均衡组名称。**

proxy_next_upstream用来定义故障转移策略，当后端服务节点返回500、502、
503、504和执行超时等错误时，自动将请求转发到upstream负载均衡组中的另一台服务器，实现故障转移。最后通过include指令包含进来一个proxy.conf文件。

其中\ ``/opt/nginx/conf/proxy.conf``\ 的内容如下：

::

   proxy_redirect off；
   proxy_set_header Host$host；
   proxy_set_header X-Real-IP$remote_addr；
   proxy_set_header X-Forwarded-For$proxy_add_x_forwarded_for；
   client_body_buffer_size128k；
   proxy_connect_timeout90；
   proxy_send_timeout90；
   proxy_read_timeout90；
   proxy_buffer_size4k；
   proxy_buffers432k；
   proxy_busy_buffers_size64k；

Nginx的代理功能是通过\ **http proxy模块**\ 来实现的。

默认在安装Nginx时已经安装了http proxy模块，因此可直接使用http
proxy模块。

下面详细解释proxy.conf文件中每个选项代表的含义。

::

   proxy_set_header：设置由后端的服务器获取用户的主机名或真实IP地址，以及代理者的真实IP地址。

   client_body_buffer_size：用于指定客户端请求主体缓冲区大小，可以理解为先保存到本地再传给用户。

   proxy_connect_timeout：表示与后端服务器连接的超时时间，即发起握手等候响应的超时时间。

   proxy_send_timeout：表示后端服务器的数据回传时间，即在规定时间之内后端服务器必须传完所有的数据，否则，Nginx将断开这个连接。

   proxy_read_timeout：设置Nginx从代理的后端服务器获取信息的时间，表示连接建立成功后，Nginx等待后端服务器的响应时间，其实是Nginx已经进入后端的排队之中等候处理的时间。

   proxy_buffer_size：设置缓冲区大小，默认该缓冲区大小等于指令
   proxy_buffers设置的大小。

   proxy_buffers：设置缓冲区的数量和大小。Nginx从代理的后端服务器获取的响应信息，会放置到缓冲区。

   proxy_busy_buffers_size：用于设置系统很忙时可以使用的proxy_buffers大小，官方推荐的大小为proxy_buffers×2。
   proxy_temp_file_write_size：指定proxy缓存临时文件的大小。

11.2 Nginx负载均衡策略
^^^^^^^^^^^^^^^^^^^^^^

轮询
''''

轮询（Round Robin）策略是 Nginx
配置中默认的负载均衡策略，该策略将客户端的请求依次分配给后端的服务器节点，对后端集群中的服务器实现轮流分配。轮询策略绝对均衡，且实现简单，但也会因后端服务器处理能力的不同而影响整个集群的处理性能。

*1) 加权轮询*

在 Nginx
的轮询策略中，为了避免因集群中服务器性能的差异对整个集群性能造成影响，在轮询策略的基础上增加了权重参数，让使用者可以手动根据集群中各服务器的性能将请求数量按照权重比例分配给不同的被代理服务器。

*2) 平滑轮询*

在加权轮询策略中，会按照权重的高低分配客户端请求，若按照高权重分配完再进行低权重分配的话，可能会出现的情况是高权重的服务器一直处于繁忙状态，压力相对集中。Nginx
通过平滑轮询算法，使得上游服务器组中的每台服务器在总权重比例分配不变的情况下，均能参与客户端请求的处理，有效避免了在一段时间内集中将请求都分配给高权重服务器的情况发生。

配置样例如下：

::

   http {
       upstream backend {
           server a weight=5;
           server b weight=1;
           server c weight=1;
       }

       server {
           listen 80;

           location / {
               proxy_pass http://backend;
           }
       }
   }

一致性哈希
''''''''''

Nginx 启用哈希的负载均衡策略，是用 hash
指令来设置的。哈希策略方法可以针对客户端访问的 URL 计算哈希值，对相同的
URL 请求，Nginx
可以因相同的哈希值而将其分配到同一后端服务器。当后端服务器为缓存服务器时，将极大提高命中率，提升访问速度。

一致性哈希的优点是，可以使不同客户端的相似请求发送给同一被代理服务器，当被代理服务器为缓存服务器场景应用时，可以极大提高缓存的命中率。

一致性哈希的缺点是，当上游服务器组中的节点数量发生变化时，将导致所有绑定被代理服务器的哈希值重新计算，影响整个集群的绑定关系，产生大量回源请求。

配置样例如下：

::

   http {
       upstream backend {
           hash $request_uri;  # 以客户端请求URI为计算哈希值的key
           server a weight=5;
           server b weight=1;
           server c weight=1;
       }

       server {
           listen 80;

           location / {
               proxy_pass http://backend;
           }
       }
   }

IP哈希
''''''

IP 哈希（IP
Hash）负载均衡策略根据客户端IP计算出哈希值，然后把请求分配给该数值对应的被代理服务器。在哈希值不变且被代理服务器可用的前提下，同一客户端的请求始终会被分配到同一台被代理服务器上。IP
哈希负载均衡策略常被应用在会话（Session）保持的场景。

::

   # Nginx负载均衡
   upstream qq_com // 自定义名字
   {
       ip_hash; // 让同一个用户始终保持在同一个服务器上
       server 61.135.157.156:80; // 定义 server 地址
       server 125.33.240.113:80;
   }
   server
   {
       listen 80; // 监听端口
       server_name www.qq.com; // 网站域名
       location /
       {
           proxy_pass http://qq_com;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       }
   }

最少连接
''''''''

默认配置下轮询算法是把客户端的请求平均分配给每个被代理服务器，每个被代理服务器的负载大致相同，该场景有个前提就是每个被代理服务器的请求处理能力是相当的。如果集群中某个服务器处理请求的时间比较长，那么该服务器的负载也相对增高。在最少连接（least_conn）负载均衡策略下，会在上游服务器组中各服务器权重的前提下将客户端请求分配给活跃连接最少的被代理服务器，进而有效提高处理性能高的被代理服务器的使用率。

配置样例如下：

::

   upstream backend {
       least_conn;         # 启用最少连接负载均衡策略
       server a weight=4;
       server b weight=2;
       server c weight=1;
   }

   server {
       listen 80;
       location / {
           proxy_pass http://backend;
       }
   }

随机负载算法
''''''''''''

在 Nginx 集群环境下，每个 Nginx
均通过自身对上游服务器的了解情况进行负载均衡处理，这种场景下，很容易出现多台
Nginx
同时把请求都分配给同一台被代理服务器的场景，该场景被称为羊群行为（Herd
Behavior）。

Nginx 基于两种选择的力量（Power of Two
Choices）原理，设计了随机（Random）负载算法。该算法使 Nginx
不再基于片面的情况了解使用固有的负载均衡策略进行被代理服务器的选择，而是随机选择两个，在经过比较后进行最终的选择。随机负载算法提供了一个参数
two，当这个参数被指定时，Nginx
会在考虑权重的前提下，随机选择两台服务器，然后用以下几种方法选择一个服务器。

-  最少连接数，配置指令为 least_conn，默认配置；
-  响应头最短平均时间，配置指令为 least_time=header，仅对商业版本有效；
-  完整请求最短平均时间，配置指令为
   least_time=last_byte，仅对商业版本有效。

配置样例如下：

::

   upstream backend {
       random two least_conn;
       server backend1.example.com;
       server backend2.example.com;
       server backend3.example.com;
       server backend4.example.com;
   }

在只有单台 Nginx 服务器时，一般不建议使用随机负载算法。

12.Nginx的压缩输出配置
~~~~~~~~~~~~~~~~~~~~~~

gzip（GNU-ZIP）是一种压缩技术。经过gzip压缩后页面大小可以变为原来的30％甚至更小。这样，用户浏览页面的时候速度会快得多。

gzip的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。

浏览器那里不需要我们担心，因为IE、Firefox、Opera、谷歌Chrome等绝大多数浏览器都支持解析gzip过的页面。

Nginx的压缩输出由一组gzip压缩指令来实现。我们从示例入手，来学习gzip压缩输出。gzip压缩输出的相关指令位于http{……}两个大括号之间：

::

   gzip on；
   gzip_min_length 1k；
   gzip_buffers 416k；
   gzip_http_version 1.1；
   gzip_comp_level 2；
   gzip_types text/plain application/x-javascript text/css
   application/xml；
   gzip_vary on；

13.Nginx的自动列目录配置
~~~~~~~~~~~~~~~~~~~~~~~~

我们经常会看到一些开源软件的下载页面是能够自动列目录的，这一功能Apache可以实现，Nginx同样可以实现，前提条件是当前目录下不存在用index指令设置的默认首页文件。如果须要在某一虚拟主机的location/{……}目录控制中配置自动列目录，只须加上如下代码：

::

   location / {
       autoindex on;
   }

另外，还有两项跟指定列目录相关的指令，分别为：

**设定索引时文件大小的单位(B、KB、MB或GB)**

::

   autoindex_exact_size [ on|off ]

**开启本地时间来显示文件的时间的功能。默认为关（GMT时间）**

::

   autoindex_localtime [ on|off ]

14.Nginx的浏览器本地缓存设置
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

浏览器缓存（Browser
Caching）是为了加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。

缓存的方式节约了网络的资源，提高了网络的效率。浏览器缓存可以通过expires指令输出Header头来实现，expires指令的语法如下：

::

   语法：expires [time|epoch|max|off]
   默认值：expires off
   作用域：http，server，location
   用途：使用本指令可以控制HTTP应答中的“Expires”和“Cache-Control”的Header头信息（起到控制页面缓存的作用）。

可以在time值中使用正数或负数。

“Expires”头标的值将通过当前系统时间加上您设定的time值来获得。

epoch指定“Expires”的值为1 January，1970，00:00:01 GMT。

max指定“Expires”的值为31 December 2037 23:59:59
GMT，“Cache-Control”的值为10年。-1指定“Expires”的值为服务器当前时间-1s，即永远过期。

“Cache-Control”头标的值由您指定的时间来决定。 负数：Cache-Control:
no-cache。正数或零： Cache-Control: max-age=#，#为您指定时间的秒数。
“off”表示不修改“Expires”和“Cache-Control”的值。

假设一个HTML页面中会引用一些JavaScript文件、图片文件，而这些格式的文件很少会被修改，则可以通过expires设置浏览器缓存。

例：对常见格式的图片、Flash文件在浏览器本地缓存30天，对js、css文件在浏览器本地缓存1小时，代码如下：

::

   location ~.*\(gif|jpg|jpeg|png|bmp|swf)${
       expires 30d;
   }

   location ~.*\(js|css)?${
       expires 1h;
   }

15.Nginx实现数据库端口转发
~~~~~~~~~~~~~~~~~~~~~~~~~~

https://www.cnblogs.com/kazihuo/p/10755972.html

16.Nginx配置SSL
~~~~~~~~~~~~~~~

16.1 生成SSL密钥对
^^^^^^^^^^^^^^^^^^

把公钥和私钥放到\ ``/usr/local/nginx/conf``\ 目录下，生成私钥操作命令如下。

::

   cd /usr/local/nginx/conf
   openssl genrsa -des3 -out tmp.key 2048

转换密钥，取消密码

::

   openssl rsa -in tmp.key -out hujianli.key
   rm -rf tmp.key

生成证书请求文件，用该文件和私钥一起生成公钥文件，hujianli.crt为公钥，操作命令如下

::

   openssl req -new -key hujianli.key -out hujianli.csr
   openssl x509 -req -days 365 -in hujianli.csr -signkey hujianli.key -out hujianli.crt
   ls hujianli.
   hujianli.crt hujianli.csr hujianli.key

.. _nginx配置ssl-1:

16.2 Nginx配置SSL
^^^^^^^^^^^^^^^^^

::

   server
   {
       listen 443;
       server_name humingzhe.com;
       index index.html index.htm index.php;
       root /data/www/defaul/humingzhe.com;
       ssl on;
       ssl_certificate hujianli.crt;
       ssl_certificate_key hujianli.key;
       ssl_protocols TLSv1 TLSV1.1 TLSV1.2;
   }

Ngin需要支持SSL，要重新编译Nginx，编译完成后，检测配置文件无误再重启Nginx，操作如下：

.. code:: shell

   cd /usr/local/src/nginx-1.13.8
   ./configure --prefix=/usr/local/nginx --with-http_ssl_module
   make && make install
   /etc/init.d/nginx restart

在default目录下创建一个测试文件，并把域名写入hosts文件中，操作命令如下。

.. code:: shell

   vim /data/www/default/test.html
   This Is SSL

   vim /etc/hosts
   127.0.0.1   hujianli.com hujianli.cn

打开浏览器进行验证。地址栏中输入域名如果提示连接不安全，证明SSL配置已生效。

Nginx性能优化技巧
-----------------

1.编译安装过程优化
~~~~~~~~~~~~~~~~~~

1.减小Nginx编译后的文件大小
在编译Nginx时，默认以debug模式进行，而在debug模式下会插入很多跟踪和
ASSERT之类的信息，编译完成后，一个Nginx要有好几兆字节。而在编译前取消
Nginx的debug模式，编译完成后Nginx只有几百千字节。因此可以在编译之前，修
改相关源码，取消debug模式。具体方法如下：

::

   在Nginx源码文件被解压后，找到源码目录下的auto/cc/gcc文件，

   在其中找到如下几行：
   #debug CFLAGS=”$CFLAGS-g”注释掉或删掉这两行，即可取消debug模式。

2.为特定的CPU指定CPU类型编译优化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

   在编译Nginx时，默认的GCC编译参数是“-O”，要优化GCC编译，可以使用以下两
   个参数：
   --with-cc-opt='-O3'
   --with-cpu-opt=CPU      

   #为特定的CPU编译，有效的值包括：
   pentium,pentiumpro,pentium3，
   #pentium4，athlon,opteron,amd64，sparc32，sparc64，ppc64

   要确定CPU类型，可以通过如下命令：

   [root@localhosthome]#cat/proc/cpuinfo|grep"model name"

3.利用TCMalloc优化Nginx的性能
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TCMalloc（Thread-Caching
Malloc）是谷歌开发的开源工具“google-perftools”中的一个成员。与标准的glibc库的malloc相比，TCMalloc库在内存分配效率和速度上要高很多，这在很大程度上提高了服务器在高并发情况下的性能，从而降低系统负载。下面简单介绍如何为Nginx添加TCMalloc库支持。

要安装TCMalloc库，需要安装libunwind（32位操作系统不需要安装）和google-perftools两个软件包，libunwind库为基于64位CPU和操作系统的程序提供了基本函数调用链和函数调用寄存器功能。下面介绍利用TCMalloc优化Nginx的具体操作过程。

1.安装libunwind库

可以从http://download.savannah.gnu.org/releases/libunwind下载相应的libunwind版本，这里下载的是libunwind-1.1.tar.gz，安装过程如下：

--------------

::

   [root@localhost app]# tar zxvf libunwind-1.1.tar.gz
   [root@localhost app]# cd libunwind-1.1/
   [root@localhost libunwind-1.1]# CFLAGS=-fPIC ./configure
   [root@localhost libunwind-1.1]# make CFLAGS=-fPIC
   [root@localhost libunwind-1.1]# make CFLAGS=-fPIC install

--------------

2.安装google-perftools

可以从https://code.google.com/p/gperftools下载相应的google-perftools版本，这里下载的是gperftools-2.1.tar.gz，安装过程如下：

--------------

::

   [root@localhost app]# tar zxvf gperftools-2.1.tar.gz
   [root@localhost app]# cd gperftools-2.1/
   [root@localhost gperftools-2.1]# ./configure
   [root@localhost gperftools-2.1]# make && make install
   [root@localhost gperftools-2.1]# echo "/usr/local/lib" > /etc/ld.so.conf.d/usr_
   local_lib.conf
   [root@localhost gperftools-2.1]# ldconfig

--------------

至此，google-perftools安装完成。

3.重新编译Nginx

为了使Nginx支持google-perftools，需要在安装过程中添加“–with-google_perftools_module”选项重新编译Nginx，安装代码如下：

--------------

::

   [root@localhost nginx-1.4.7]# ./configure --prefix=/usr/local/nginx \
   > --with-google_perftools_module --with-http_stub_status_module
   [root@localhost nginx-1.4.7]# make
   [root@localhost nginx-1.4.7]# make install

--------------

到这里Nginx安装完成。

4.为google-perftools添加线程目录

创建一个线程目录，这里将文件放在/tmp/tcmalloc下，操作如下：

--------------

::

   [root@localhost app]# mkdir /tmp/tcmalloc
   [root@localhost app]# chmod 0777 /tmp/tcmalloc

--------------

5.修改Nginx主配置文件

修改nginx.conf文件，在pid这行的下面添加如下代码：

--------------

::

   #pid        logs/nginx.pid;
   google_perftools_profiles /tmp/tcmalloc;

--------------

接着，重启Nginx，完成google-perftools的加载。

6.验证运行状态

为了验证google-perftools已经正常加载，通过如下命令查看：

--------------

::

   [root@ localhost app]# lsof -n | grep  tcmalloc
   nginx      2395 nobody   9w   REG   8,8   0    1599440  /tmp/tcmalloc.2395
   nginx      2396 nobody   11w  REG   8,8   0    1599443  /tmp/tcmalloc.2396
   nginx      2397 nobody   13w  REG   8,8   0    1599441  /tmp/tcmalloc.2397
   nginx      2398 nobody   15w  REG   8,8   0    1599442  /tmp/tcmalloc.2398

--------------

由于在Nginx配置文件中，设置worker_processes的值为4，因此开启了4个Nginx线程，每个线程会有一行记录。每个线程文件后面的数字值就是启动的Nginx的PID值。

至此，利用TCMalloc优化Nginx的操作完成。

4.Nginx内核参数优化
~~~~~~~~~~~~~~~~~~~

::

   net.ipv4.tcp_max_tw_buckets=6000
   net.ipv4.ip_local_port_range=102465000
   net.ipv4.tcp_tw_recycle=1
   net.ipv4.tcp_tw_reuse=1
   net.ipv4.tcp_syncookies=1
   net.core.somaxconn=262144
   net.core.netdev_max_backlog=262144
   net.ipv4.tcp_max_orphans=262144
   net.ipv4.tcp_max_syn_backlog=262144
   net.ipv4.tcp_synack_retries=1
   net.ipv4.tcp_syn_retries=1
   net.ipv4.tcp_fin_timeout=1
   net.ipv4.tcp_keepalive_time=30

将上面的内核参数值加入\ ``/etc/sysctl.conf``\ 文件中，
然后执行如下命令使之生效：

::

   [root@localhost home]#/sbin/sysctl-p

**下面对实例中选项的含义进行介绍**\ ：

::

   net.ipv4.tcp_max_tw_buckets
   #选项用来设定timewait的数量，默认是180000，这里设为6000。

   net.ipv4.ip_local_port_range
   #选项用来设定允许系统打开的端口范围。

   net.ipv4.tcp_tw_recycle。
   #选项用于设置启用timewait快速回收

   net.ipv4.tcp_tw_reusesockets
   #选项用于设置开启重用，允许将TIME-WAIT 重新用于新的TCP连接。

   net.ipv4.tcp_syncookies
   #选项用于设置开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies进行处理。

   net.core.somaxconn
   #选项的默认值是128，这个参数用于调节系统同时发起的tcp
   连接数，在高并发的请求中，默认的值可能会导致链接超时或者重传，因此，需要
   结合并发请求数来调节此值。

   net.core.netdev_max_backlog
   #选项表示当每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目。

   net.ipv4.tcp_max_orphans
   #选项用于设定系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤立连接将立即被复位并打印
   出警告信息。这个限制只是为了防止简单的DoS攻击。不能过分依靠这个限制甚至人为减小这个值，更多的情况下应该增加这个值。

   net.ipv4.tcp_max_syn_backlog
   #选项用于记录那些尚未收到客户端确认信息的连接请求的最大值。对于有128MB内存的系统而言，此参数的默认值是1024，对小内存的系统则是128。

   net.ipv4.tcp_synack_retries
   #参数的值决定了内核放弃连接之前发送SYN+ACK包的数量。

   net.ipv4.tcp_syn_retries
   #选项表示在内核放弃建立连接之前发送SYN包的数量。


   net.ipv4.tcp_fin_timeout
   #选项决定了套接字保持在FIN-WAIT-2状态的时间。默
   认值是60秒。正确设置这个值非常重要，有时即使一个负载很小的Web服务器，也会出现大量的死套接字而产生内存溢出的风险。

   net.ipv4.tcp_syn_retries
   #选项表示在内核放弃建立连接之前发送SYN包的数量。
   #如果发送端要求关闭套接字，net.ipv4.tcp_fin_timeout选项决定了套接字保持在FIN-WAIT-2状态的时间。接收端可以出错并永远不关闭连接，甚至意外宕机。


   net.ipv4.tcp_fin_timeout的默认值是60秒。需要注意的是，即使一个负载很小的Web服务器，也会出现因为大量的死套接字而产生内存溢出的风险。FIN-WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能消耗1.5KB的内存，但是其生存期长些。

   net.ipv4.tcp_keepalive_time
   #选项表示当keepalive启用的时候，TCP发送keepalive消息的频度。默认值是2（单位是小时）。

实战Nginx与PHP（FastCGI）的安装、配置与优化
-------------------------------------------

FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。
多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同
时，FastCGI也被许多脚本语言支持，其中就有PHP。

FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。

.. image:: ../../_static/FsatCGI001.PNG

优点就是实现动静分离

::

   Nginx是个轻量级的HTTP server，必须借助第三方的FastCGI处理器才可以对PHP
   进行解析，因此Nginx+spawn-fcgi的组合也可以实现对PHP的解析，

   FastCGI的主要优点是把动态语言和HTTP Server分离开来，
   所以Nginx与PHP/PHP-FPM经常被部署在不同的服务器上，以分担前端Nginx服务器的压力，使
   Nginx专一处理静态请求和转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求。

具体实现细节，这里就不展开了，知道原理之后可以百度操作安装过程

参考文献：

`实战Nginx与PHP（FastCGI）的安装、配置与优化-靠谱运维-51CTO博客 <https://blog.51cto.com/ixdba/806622>`__

http://zyan.cc/nginx_php_v6/

php-fpm的pool
~~~~~~~~~~~~~

php-fpm的pool是pho-fpm服务的池子，php-fpm支持定义多个池子。它能够监听多个不同的sock或不同的IP。

如果Nginx删高云翔了多个站点，那么每个站点都可以设置一个Pool，当其中一个站点的PHP报502状态时，其他的站点不受任何影响。如果全部站点都使用同一个pool，那么如果一个站点PHP出现问题，整站全部瘫痪。

**所以需要给每个站点都设置一个pool，把这些站点隔离开**

vhost目录下存在多个.conf配置文件，因为nginx.conf配置文件中定义了

``include vhost/*.conf;``\ 。php-fpm同样支持这样操作，在\ ``php-fpm.conf``\ 配置文件中增加如下代码。

::

   cd /usr/local/php-fpm/etc/

   vim php-fpm.conf
   [global]
   pid = /usr/local/php-fpm/var/run/php-fpm.pid
   error_log = /usr/local/php-fpm/var/log/php-fpm.log
   include = /etc/php-fpm.d/*.conf

创建php-fpm.d目录，在php-fpm.d目录下创建www.conf和web01.conf文件，文件如下

www.conf

::

   [www]
   listen = /tmp/www.sock
   #listen = 127.0.0.1:9000
   listen.mode = 666
   user = php-fpm
   group = php-fpm
   pm = dynamic
   pm.max_children = 50
   pm.start_servers = 20
   pm.min_spare_servers = 5
   pm.max_spare_servers = 35
   pm.max_requests = 500
   rlimit_files = 1024

web01.conf

::

   [web01]
   listen = /tmp/web01.sock
   #listen = 127.0.0.1:9000
   listen.mode = 666
   user = php-fpm
   group = php-fpm
   pm = dynamic
   pm.max_children = 50
   pm.start_servers = 20
   pm.min_spare_servers = 5
   pm.max_spare_servers = 35
   pm.max_requests = 500
   rlimit_files = 1024

检查语法无误后重载php-fpm，查看设置的web01进程池，如下：

.. code:: shell

   /usr/local/php-fpm/sbin/php-fpm -t

   /etc/init.d/php-fpm reload

   ps aux |grep php-fpm

php-fpm慢执行日志
~~~~~~~~~~~~~~~~~

在日常运维工作中经常遇到网站访问速度慢的情况。排查原因可以通过php-fpm慢执行日志查看。

::

   vim /etc/php-fpm.d/www.conf
   request_slowlog_timeout = 1
   slowlog = /usr/local/php-fpm/var/log/www-slow.log

   ls /usr/local/php-fpm/var/log/www-slow.log

加载完毕，检查语法无误后，重载php-fpm。查看www-slow.log，根据日志进行排查问题。

参考文献
~~~~~~~~

`php-fpm的pool、php-fpm慢执行日志、open_basedir、php-fpm进程管理 <https://www.cnblogs.com/lms0755/p/9179173.html>`__

实战Nginx与Perl、Java的安装与配置
---------------------------------

通过前面的介绍，可以对Nginx有了一个比较全面的认识：Nginx本身是一个静态的
HTTP服务器和反向代理服务器，它不支持动态页面，所谓的Nginx对动态程序的支持都是通过反向代理功能实现的。

下面要讲述的Nginx对Perl和JSP的支持，就是通过Nginx的反向代理功能来完成的。

1.Nginx+Perl（FastCGI）

2.Nginx+Tomcat的实例来讲解Nginx对Java的支持。

Nginx可以通过以下两种方式来实现与Tomcat的耦合：

::

   * 将静态页面请求交给Nginx，动态请求交给后端Tomcat处理。
   * 将所有请求都交给后端的Tomcat服务器处理，同时利用Nginx自身的负载均衡功能进行多台Tomcat服务器的负载均衡。

通过两个配置实例分别讲述这两种实现Nginx与Tomcat耦合的方式。

1.动态页面与静态页面分离的实例

::

   server{
       listen 80；
       server_name www.ixdba.net；
       root /web/www/html；
       location /img/{
           alias /web/www/html/img/；
       }
       location ～(\.jsp)|(\.do)${
           proxy_pass http://192.168.12.130:8080；
           proxy_redirect off；
           proxy_set_header Host $host；
           proxy_set_header X-Real-IP $remote_addr；
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for；
           client_max_body_size 10m；
           client_body_buffer_size 128k；
           proxy_connect_timeout 90；
           proxy_send_timeout 90；
           proxy_read_timeout 90；
           proxy_buffer_size 4k；
           proxy_buffers 432k；
           proxy_busy_buffers_size 64k；
           proxy_temp_file_write_size 64k；
   }

在这个实例中，首先定义了一个虚拟主机www.ixdba.net，然后通过location指
令将/web/www/html/img/目录下的静态文件交给Nginx来完成。最后一个
location指令将所有以.jsp、.do结尾的文件都交给Tomcat服务器的8080端口来处
理，即http://192.168.12.130：8080。

::

   需要特别注意的是，在location指令中使用正则表达式后，proxy_pass后面的代理路径不能含有地址链接，
   也就是不能写成http://192.168.12.130:8080/，
   或者类似http://192.168.12.130:8080/jsp的形式。
   在location指令不使用正则表达式时，没有此限制。

2.多个Tomcat负载均衡的实例

这里假定有3台Tomcat服务器，分别开放不同的端口，地址如下：

::

   192.168.12.131：8000
   192.168.12.132：8080
   192.168.12.133：8090

Nginx的相关配置代码如下：

::

       upstream mytomcats{
           server 192.168.12.131：8000；
           server 192.168.12.132：8080；
           server 192.168.12.133：8090；
       }
       server{
           listen 80；
           server_name www.ixdba.net；
           location ～*\.（jpg|gif|png|swf|flv|wma|wmv|asf|mp3|mmf|zip|rar）${
           root /web/www/html/；
       }
       location /{
       proxy_pass http://mytomcats；
       proxy_redirect off；
       proxy_set_header Host $host；
       proxy_set_header X-Real-IP $remote_addr；
       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for；
       client_max_body_size 10m；
       client_body_buffer_size 128k；
       proxy_connect_timeout 90；
       proxy_send_timeout 90；
       proxy_read_timeout 90；
       proxy_buffer_size 4k；
       proxy_buffers 432k；
       proxy_busy_buffers_size 64k；
       proxy_temp_file_write_size 64k；
       }
       }

在这个实例中，先通过upstream定义一个负载均衡组，组名为mytomcats，组的成员就是上面指定的3台Tomcat服务器；
接着通过server指令定义一个www.ixdba.net的虚拟主机；然后通过location指令以正则表达式的方式将指定类
型的文件全部交给Nginx去处理；最后将其他所有请求全部交给负载均衡组来处理。

::

   这里还有一点需要注意，如果在location指令使用正则表达式后再用alias指令，Nginx是不支持的。

以上就通过实例分别演示了Nginx与PHP整合，Nginx和Java、Perl整合的过程。

参考文献：

`实战Nginx与Perl、Java的安装与配置-靠谱运维-51CTO博客 <https://www.baidu.com/link?url=jfh21hXDoAbUaSdDN2HuU22UGX9a5C-NjhTP4BWqnuHYZkpVIqDjgK_52FQKB_nw&wd=&eqid=b5e608df000174ae000000025ea2abc5>`__
