<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6.7. Redis—App后台高性能的缓存系统 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="6.8. MongoDB—App后台新兴的数据库" href="08.MongoDB%E2%80%94App%E5%90%8E%E5%8F%B0%E6%96%B0%E5%85%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.html" />
    <link rel="prev" title="6.6. MySQL—App后台最常用的数据库" href="06.MySQL%E2%80%94App%E5%90%8E%E5%8F%B0%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> 小健_Linux-shell-Devops_Blog
            <img src="../../_static/devops_photo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../DevOps/index.html">DevOps和自动化运维实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Github/index.html">Github入门到实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Jenkins/index.html">Jenkins持续化集成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../KVM/index.html">KVM实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Linux/index.html">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Mysql/index.html">Mysql王者之路</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Other</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../01.Git%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E7%BB%83/index.html">1. Git入门到熟练</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02.%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%B9%A6%E5%8D%9A%E5%AE%A2/index.html">2. 构建写书博客</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03.Vim%E6%95%99%E7%A8%8B/index.html">3. Vim教程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../04.SQL-Server%E5%AD%A6%E4%B9%A0/index.html">4. SQL-Server学习</a></li>
<li class="toctree-l2"><a class="reference internal" href="../05.%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/index.html">5. 程序员实用工具网站</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">6. APP后台开发运维_读书笔记</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="01.APP%E5%90%8E%E5%8F%B0%E5%85%A5%E9%97%A8.html">6.1. APP后台入门</a></li>
<li class="toctree-l3"><a class="reference internal" href="02.APP%E5%90%8E%E5%8F%B0%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF.html">6.2. APP后台基础技术</a></li>
<li class="toctree-l3"><a class="reference internal" href="03.APP%E5%90%8E%E5%8F%B0%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html">6.3. APP后台核心技术</a></li>
<li class="toctree-l3"><a class="reference internal" href="04.Linux-APP%E5%90%8E%E5%8F%B0%E5%BA%94%E7%94%A8%E6%9C%80%E5%B9%BF%E6%B3%9B%E7%9A%84%E7%B3%BB%E7%BB%9F.html">6.4. Linux-APP后台应用最广泛的系统</a></li>
<li class="toctree-l3"><a class="reference internal" href="05.Nginx%E2%80%94App%E5%90%8E%E5%8F%B0HTTP%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%A9%E5%99%A8.html">6.5. Nginx—App后台HTTP服务的利器</a></li>
<li class="toctree-l3"><a class="reference internal" href="06.MySQL%E2%80%94App%E5%90%8E%E5%8F%B0%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.html">6.6. MySQL—App后台最常用的数据库</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.7. Redis—App后台高性能的缓存系统</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#redis">6.7.1. Redis简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">6.7.2. Redis的常用数据结构及应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">6.7.3. 内存优化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id36">6.7.4. 集群</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id43">6.7.5. 持久化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id44">6.7.6. 故障排除案例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="08.MongoDB%E2%80%94App%E5%90%8E%E5%8F%B0%E6%96%B0%E5%85%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.html">6.8. MongoDB—App后台新兴的数据库</a></li>
<li class="toctree-l3"><a class="reference internal" href="09.%E6%9E%B6%E6%9E%84%E9%80%89%E5%9E%8B%E7%9A%84%E8%A6%81%E7%82%B9.html">6.9. 架构选型的要点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../07.%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/index.html">7. 一些常用的工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="../08.Windows%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/index.html">8. Windows系统相关</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Network_route_switch/index.html">Network_route_switch</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">小健_Linux-shell-Devops_Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Other</a> &raquo;</li>
          <li><a href="index.html"><span class="section-number">6. </span>APP后台开发运维_读书笔记</a> &raquo;</li>
      <li><span class="section-number">6.7. </span>Redis—App后台高性能的缓存系统</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/other/06.APP后台开发运维_读书笔记/07.Redis—App后台高性能的缓存系统.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#redisapp" id="id46">Redis—App后台高性能的缓存系统</a></p>
<ul>
<li><p><a class="reference internal" href="#redis" id="id47">Redis简介</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id48">Redis的常用数据结构及应用场景</a></p>
<ul>
<li><p><a class="reference internal" href="#string" id="id49">string——存储简单的数据</a></p></li>
<li><p><a class="reference internal" href="#hash" id="id50">hash——存储对象的数据</a></p></li>
<li><p><a class="reference internal" href="#list" id="id51">list——模拟队列操作</a></p></li>
<li><p><a class="reference internal" href="#set" id="id52">set——无序且不重复的元素集合</a></p></li>
<li><p><a class="reference internal" href="#sorted-set" id="id53">sorted set——有序且不重复的元素集合</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id31" id="id54">内存优化</a></p>
<ul>
<li><p><a class="reference internal" href="#id32" id="id55">监控内存使用的状况</a></p></li>
<li><p><a class="reference internal" href="#id33" id="id56">优化存储结构</a></p></li>
<li><p><a class="reference internal" href="#id34" id="id57">限制使用的最大内存</a></p></li>
<li><p><a class="reference internal" href="#id35" id="id58">设置过期时间</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id36" id="id59">集群</a></p>
<ul>
<li><p><a class="reference internal" href="#id37" id="id60">1.客户端分片</a></p></li>
<li><p><a class="reference internal" href="#twemproxy" id="id61">2.Twemproxy</a></p></li>
<li><p><a class="reference internal" href="#codis" id="id62">3.Codis</a></p></li>
<li><p><a class="reference internal" href="#redis-3-0" id="id63">4.Redis 3.0集群</a></p></li>
<li><p><a class="reference internal" href="#id38" id="id64">5.云服务器上的集群服务</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id43" id="id65">持久化</a></p>
<ul>
<li><p><a class="reference internal" href="#rdb" id="id66">RDB</a></p></li>
<li><p><a class="reference internal" href="#aof" id="id67">AOF</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id44" id="id68">故障排除案例</a></p>
<ul>
<li><p><a class="reference internal" href="#id45" id="id69">Redis崩溃的故障</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="redisapp">
<h1><a class="toc-backref" href="#id46"><span class="section-number">6.7. </span>Redis—App后台高性能的缓存系统</a><a class="headerlink" href="#redisapp" title="Permalink to this headline">¶</a></h1>
<p>用户对App后台的响应速度要求越来越高。把数据存储在硬盘上，由于受到硬盘读写速度的限制，因此数据读写的速度有限。内存比硬盘的读写速度高了一个数量级，因此基于内存的数据读取也比硬盘提高了一个数量级，而Redis正是基于内存存储数据，保证了数据快速的读写速度。同时Redis提供了丰富的数据类型（string、hash、list、set及zset），给开发者带来了很大的便利。</p>
<section id="redis">
<h2><a class="toc-backref" href="#id47"><span class="section-number">6.7.1. </span>Redis简介</a><a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h2>
<p>MySQL被广泛用于数据存储，但MySQL读写速度慢，随着移动互联网的发展，越来越多的业务场景需要满足下面的需求。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·少量数据需要被经常读写，同时对读写速度要求非常高。
·能提供丰富的数据结构。
·提供数据落地的功能。
</pre></div>
</div>
<p>所下表所展示了计算机中主要存储介质的访问速度。</p>
<p>计算机中主要存储介质的访问速度</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 68%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>介质</p></th>
<th class="head"><p>时间</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>内存寻址</p></td>
<td><p>100纳秒</p></td>
</tr>
<tr class="row-odd"><td><p>从内存中顺序读取1MB的数据</p></td>
<td><p>250000纳秒</p></td>
</tr>
<tr class="row-even"><td><p>磁盘寻址</p></td>
<td><p>250000纳秒</p></td>
</tr>
<tr class="row-odd"><td><p>从磁盘中顺序读取1MB的数据</p></td>
<td><p>20000000纳秒</p></td>
</tr>
</tbody>
</table>
<p>从内存中顺序读取1MB的数据耗时250000纳秒，从磁盘中顺序读取1MB的数据耗时20000000纳秒，内存的读取速度是硬盘的读取速度的80倍。因此可以通过把内存数据存储在内存来提升系统的性能</p>
<p>Redis就是一个满足上面需求的开源Key-Value内存存储系统。Key-Value存储系统在写入的时候，通过指定Key及其对应的Value；读取的时候，通过指定Key就能读取Value的值。Redis有以下的特点</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·全部的数据操作在内存，保证了高速的读写速度。
·提供丰富多样的数据类型：string、hash、list、set、sorted set、bitmap和hyperloglog。

MySQL被广泛用于数据存储，但MySQL读写速度慢，随着移动互联网的发展，越来越多的业务场景需要满足下面的需求。

少量数据需要被经常读写，同时对读写速度要求非常高。
能提供丰富的数据结构。
提供数据落地的功能。
如表7-1所示展示了计算机中主要存储介质的访问速度。

表7-1　计算机中主要存储介质的访问速度

介质  时间
内存寻址    100纳秒
从内存中顺序读取1MB的数据  250000纳秒
磁盘寻址    10000000纳秒
从磁盘中顺序读取1MB的数据  20000000纳秒
读者在表7-1中可了解，从内存中顺序读取1MB的数据耗时250000纳秒，从磁盘中顺序读取1MB的数据耗时20000000纳秒，内存的读取速度是硬盘的读取速度的80倍。因此可以通过把内存数据存储在内存来提升系统的性能。

Redis就是一个满足上面需求的开源Key-Value内存存储系统。Key-Value存储系统在写入的时候，通过指定Key及其对应的Value；读取的时候，通过指定Key就能读取Value的值。Redis有以下的特点。

·全部的数据操作在内存，保证了高速的读写速度。
·提供丰富多样的数据类型：string、hash、list、set、sorted set、bitmap和hyperloglog。
·提供了AOF和RDB两种数据的持久化方式，保证了Redis重启后数据不丢失。
·Redis的所有操作都是原子性，同时Redis还支持对几个操作合并后的原子性操作，也即支持事务。
</pre></div>
</div>
<p>Redis丰富多样的数据类型给数据存储提供了一种新的思路，其让广大的开发者存储数据的时候，不用再面对功能单一的数据库，开发者能利用Redis提供的灵活多变的数据结构和数据操作更巧妙地存储数据。</p>
</section>
<section id="id1">
<h2><a class="toc-backref" href="#id48"><span class="section-number">6.7.2. </span>Redis的常用数据结构及应用场景</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Redis 5种常用的数据结构（string、hash、list、set、sorted s
et），以及这些数据结构所适用的业务场景。</p>
<section id="string">
<h3><a class="toc-backref" href="#id49">string——存储简单的数据</a><a class="headerlink" href="#string" title="Permalink to this headline">¶</a></h3>
<section id="id2">
<h4>1．简介<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>string类型是Redis中最基本的数据类型，其在Redis中是二进制安全，意味着这种数据类型可以接受任何格式的二进制数据，例如一张JPEG格式的图片或者JSON格式的字符串。在Redis中字符串类型最多可以容纳的数据长度是512MB。</p>
</section>
<section id="id3">
<h4>2．数据模型<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>string类型是基本的Key-Value结构，Key可以看作某个数据在Redis中的唯一标识，Value是具体的数据。下表展示了基本Key-Value数据模型：</p>
<p>基本Key-Value数据模型</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“name”</p></td>
<td><p>“hujianli”</p></td>
</tr>
<tr class="row-odd"><td><p>“city”</p></td>
<td><p>“wuhan”</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id4">
<h4>3．应用场景<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>由于string类型灵活，可以存储大量的数据，所以在App后台中，string类型经常会用来缓存数据。例如App中常见的商品分类栏，这类界面的特点是：访问频率高，数据不经常变动（可能几天）。所以为了提高这个界面的访问速度，把这个界面的数据放在Redis的一个Key-Value结构中，一般情况下App后台就从这个Key读取数据；当这个界面的数据发生变化时，用新的数据覆盖这个Key的数据。</p>
<p>假设这个界面的数据对应的Key是“category”，Value为这个界面的JSON数据
则Redis中对应的模型如表</p>
<p>分类界面对应的Key-Value</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“category”</p></td>
<td><p>{“常用分类”:……，“潮流女装”:……，…}</p></td>
</tr>
</tbody>
</table>
<p>当App端需要通过API获取这个界面的JSON数据时，API请求到达App后台通过Redis获取Key“category”对应的值，命令如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">get</span> <span class="n">category</span>
</pre></div>
</div>
<p>一般来说，App端为了在网络不可用的时候也有良好的用户体验，会在App本地也缓存一份数据，整个流程如图
<img alt="image0" src="../../_images/redis_string01.png" /></p>
<p>string这种数据类型可以用如下的两种模式的string表示，在这里分析这两种方式的问题所在。</p>
</section>
<section id="id5">
<h4>第一种用string表示的数据模型<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p><img alt="image1" src="../../_images/redis_string0001.png" /></p>
<p>第一种方式，Key是用户的id为5，Value是一个JSON格式的字符串，这种方式的缺点是存储或获取Value时，
把对象变为JSON格式或者把JSON格式变为对象需要额外的性能开销。
另外如果开发者只需要修改Value中的name值，在这种格式中，开发人员必须要先获得city值，
才能把其转化为符合Value格式的JSON值，增加了没必要的性能开销和复杂性。</p>
</section>
<section id="id6">
<h4>第二种用string表示的数据模型如图<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p><img alt="image2" src="../../_images/redis_string0002.png" />
第二种方式，有多少组用户属性就用多少个Key-Value对象，用户id“5”加上对应的属性名来作为Key，属性值作为Value。这种方式存取或获取数据，虽然免去了如第一种方式JSON/反JSON的开销，但是在内存方面的开销还是比hash的大（通过在Redis配置文件中优化“hash-max-zipmap-entries”和“hash-max-zipmap-value”这两个参数可以让hash更省内存）。</p>
</section>
</section>
<section id="hash">
<h3><a class="toc-backref" href="#id50">hash——存储对象的数据</a><a class="headerlink" href="#hash" title="Permalink to this headline">¶</a></h3>
<section id="id7">
<span id="id8"></span><h4>1．简介<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>hash类型很接近数据库模型，hash的Key是个唯一值，Value部分是个hashmap的结构。</p>
</section>
<section id="id9">
<span id="id10"></span><h4>2．数据模型<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>在数据库中有这样一行用户数据，如表</p>
<p>用户数据</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 53%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>id</p></th>
<th class="head"><p>name</p></th>
<th class="head"><p>city</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>id</p></td>
<td><p>hujianli</p></td>
<td><p>wuhan</p></td>
</tr>
</tbody>
</table>
<p>如果要在Redis中用hash结构存储，则数据模型如图</p>
<p>hash数据模型 <img alt="image3" src="../../_images/redis_hash01.png" /></p>
<p>在这个hash数据模型中，Key是用户id为5，Value是个hashmap，
hashmap的field（在Redis称内部hashmap的Key为field）
为表中的属性名（name，city），hashmap的Value为表7-4中的属性值（jeff和guangzhou）。
后台对hash数据的保存和存储，可以通过Key
（用户id）+field（属性名）来操作。</p>
</section>
<section id="id11">
<span id="id12"></span><h4>3.应用场景<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>App后台常见的功能是根据用户的id获取用户的信息。例如，根据用户的id获取用户的昵称、头像、所在地等信息。一般用户的信息是存储在数据库中，对于这种高频的数据访问，不可能每次获取这些信息都读取数据库，自然而然开发人员会考虑到把用户的信息存储在Redis的hash中.</p>
<p>如图 <img alt="image4" src="../../_images/redis_hash001.png" />
获得用户id后需要获取用户的数据，用hgetall命令获取id下所有的field和value，命令如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hgetall</span> <span class="nb">id</span>
</pre></div>
</div>
<p>注意：
如果修改了数据库的用户数据，也要把这些数据同步更新到Redis，用来防止Redis和数据库的数据不一致。</p>
</section>
</section>
<section id="list">
<h3><a class="toc-backref" href="#id51">list——模拟队列操作</a><a class="headerlink" href="#list" title="Permalink to this headline">¶</a></h3>
<section id="id13">
<span id="id14"></span><h4>1．简介<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>Redis中list是按照插入顺序排序的字符串链表，可以在头部和尾部插入新的元素（即队列结构）。插入元素时如果该Key不存在，Redis会为该Key创建一个新的链表，如果链表中所有的元素都被移除，该Key也会从Redis中移除。</p>
<p><strong>注意：</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>由于list在Redis中是链表结构，如果在头部或尾部插入新的元素，
即使链表中存储了上百万的数据，性能也非常高效。如果在链表中插入元素，
由于需要根据头部或尾部的指针遍历到链表指定的位置，Redis的插入效率很低。
</pre></div>
</div>
</section>
<section id="id15">
<span id="id16"></span><h4>2．数据模型<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>list的数据模型如图</p>
<p>链表的数据模型 <img alt="image5" src="../../_images/redis_list0001.png" /></p>
<p>常见的操作是用lpush命令在list头部插入元素，用rpop命令在list尾取出数据。</p>
</section>
<section id="id17">
<span id="id18"></span><h4>3．应用场景<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>在App后台中，Redis也经常被用来作为消息队列，理由如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·因为App后台中已经使用了Redis，消息队列也使用Redis可以减少开发人员的维护成本和学习新知识的成本。
·Redis的读写速度能达到每秒上万次，能满足大多数系统的性能要求。
</pre></div>
</div>
<p>App后台常见的发送短信功能就需要用到队列，因为发送短信的速度慢，所以需要用到队列来实现异步操作</p>
<p>发送短信的架构图 <img alt="image6" src="../../_images/redis_list0002.png" /></p>
<p>发送短信的过程如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>（1）应用程序把短信相关的信息（包括手机号、内容）转换为JSON字符串后放入“发送短信消息队列”。
（2）发送短信的守护进程是个在后台不断运行的程序，其不断地检测“发送短信消息队列”是否为空，如果不为空，就把信息从消息队列中取出。
（3）发送短信的守护进程把短信的内容发送短信平台的接口。
</pre></div>
</div>
</section>
</section>
<section id="set">
<h3><a class="toc-backref" href="#id52">set——无序且不重复的元素集合</a><a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h3>
<section id="id19">
<span id="id20"></span><h4>1.简介<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>在Redis中set类型可以看作是没有排序、不重复的元素集合，可以在该类型上添加、删除元素或者判断某一元素存在等操作（这些操作的时间复杂度是O(1)）。</p>
<p>set集合中不允许出现重复的元素，换句话说，如果多次添加相同的元素，set中只保留一份。当用户需要存储很多的数据，但又希望不出现重复的数据，这个特性就非常有用。</p>
<p>另外set类型还提供多个set之间的聚合计算，如求set之间的交集、差集或并集，这些操作是在Redis内部完成，效率特别高。</p>
</section>
<section id="id21">
<span id="id22"></span><h4>2.数据模型<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>set类型的数据模型如图</p>
<p>set的数据模型 <img alt="image7" src="../../_images/redis_set001.png" /></p>
<p>set类型的Value部分是一系列不重复的数据集合。</p>
</section>
<section id="id23">
<span id="id24"></span><h4>3.应用场景<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>社交类型的App中，有的App当用户进入了一个用户的主页后会提示共同好友的信息，以方便用户扩展社交关系。提示共同好友的页面如图</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>获取共同好友的算法如下：把用户a的所有好友取出来遍历，
和用户b的所有好友一一比较，如果相同的话就是共同好友。
</pre></div>
</div>
<p><img alt="image8" src="../../_images/redis_set0003.png" /></p>
<p>上面描述的算法其实就是求两个集合交集。在Redis的set类型的操作中已经包含了求交集的操作sinter。
如果把用户a的好友存储在集合a中，把用户b的好友存储在集合b中，通过求集合a和集合b的交集，
就能获取用户a和用户b的共同好友。 <img alt="image9" src="../../_images/redis_se0004.png" /></p>
<p>如图中，Redis中用户a的好友集合是“Jeff，Tom，Jack”，用户b的好友集合是“Jack，Terry，Mike”，对用户a和用户b的好友集合求交集，就能得到用户a和用户b的共同好友是Jack。</p>
</section>
</section>
<section id="sorted-set">
<h3><a class="toc-backref" href="#id53">sorted set——有序且不重复的元素集合</a><a class="headerlink" href="#sorted-set" title="Permalink to this headline">¶</a></h3>
<section id="id25">
<span id="id26"></span><h4>1.简介<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<p>sorted-set类型与set类型非常相似，不允许出现重复的元素。
其主要区别是sorted-set中提供了一个分数（score）与每一个成员对应，Redis根据score对成员进行排序，
而且插入是有序的，即插入后就自动排序。当App后台开发者需要有序且不重复的数据，
选择sorted-set这种数据结构就非常合适。</p>
<p>需要特别注意：sorted-set中的成员是不允许重复，但score是允许重复的。</p>
</section>
<section id="id27">
<span id="id28"></span><h4>2.数据模型<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>sorted-set的数据模型如图</p>
<p>sorted-set的数据模型 <img alt="image10" src="../../_images/redis_sorted-set01.png" /></p>
</section>
<section id="id29">
<span id="id30"></span><h4>3.应用场景<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<p>sorted-set类型适用于各种类型的排行榜。</p>
<p><img alt="image11" src="../../_images/redis_sort-set0002.png" /></p>
<p>用户如果需要使用sorted-set实现如图的用户人气榜，首先通过下面的命令把用户的数据添加到Redis中。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ZADD</span> <span class="n">key</span> <span class="n">score</span> <span class="n">member</span>
</pre></div>
</div>
<p>本例中sorted-set的Key是“userTop”，添加数据的过程如下所示。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span><span class="n">zadd</span> <span class="n">userTop</span> <span class="mi">112</span> <span class="n">mike</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">1</span>
<span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span><span class="n">zadd</span> <span class="n">userTop</span> <span class="mi">111</span> <span class="n">ekin</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">1</span>
<span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span><span class="n">zadd</span> <span class="n">userTop</span> <span class="mi">104</span> <span class="n">terry</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">1</span>
<span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span><span class="n">zadd</span> <span class="n">userTop</span> <span class="mi">179</span> <span class="n">jeff</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">1</span>
<span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span><span class="n">zadd</span> <span class="n">userTop</span> <span class="mi">127</span> <span class="n">tom</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>接着通过下面的命令返回索引在start和stop之间的成员列表。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zrevrange</span> <span class="n">key</span> <span class="n">start</span> <span class="n">stop</span> <span class="p">[</span><span class="n">withscores</span><span class="p">]</span>
</pre></div>
</div>
<p>其中start为0表示第一个成员，stop为-1表示最后一个成员，WITHSCORES表示返回的结果中包含每个成员的分数），排序命令如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">127.0.0.1</span><span class="p">:</span><span class="mi">6379</span><span class="o">&gt;</span><span class="n">zrevrange</span> <span class="n">userTop</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="n">WITHSCORES</span>
 <span class="mi">1</span><span class="p">)</span> <span class="s2">&quot;jeff&quot;</span>
 <span class="mi">2</span><span class="p">)</span> <span class="s2">&quot;179&quot;</span>
 <span class="mi">3</span><span class="p">)</span> <span class="s2">&quot;tom&quot;</span>
 <span class="mi">4</span><span class="p">)</span> <span class="s2">&quot;127&quot;</span>
 <span class="mi">5</span><span class="p">)</span> <span class="s2">&quot;mike&quot;</span>
 <span class="mi">6</span><span class="p">)</span> <span class="s2">&quot;112&quot;</span>
 <span class="mi">7</span><span class="p">)</span> <span class="s2">&quot;ekin&quot;</span>
 <span class="mi">8</span><span class="p">)</span> <span class="s2">&quot;111&quot;</span>
 <span class="mi">9</span><span class="p">)</span> <span class="s2">&quot;terry&quot;</span>
<span class="mi">10</span><span class="p">)</span> <span class="s2">&quot;104&quot;</span>
</pre></div>
</div>
<p>上面的返回结果已按照分数从大到小排序了。</p>
</section>
</section>
</section>
<section id="id31">
<h2><a class="toc-backref" href="#id54"><span class="section-number">6.7.3. </span>内存优化</a><a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h2>
<p>由于Redis在内容中存储数据的特性，Reids会占用大量的内存，
Redis的开发者也考虑到这一点，因此在Redis中提供了一系列的参数和方法来监控、控制和优化内存。</p>
<section id="id32">
<h3><a class="toc-backref" href="#id55">监控内存使用的状况</a><a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>在通过Redis的终端命令redis-cli中输入命令“info”可查看Redis的各种统计信息，其中有关内存的统计信息如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Memory</span>
 <span class="n">used_memory</span><span class="p">:</span><span class="mi">12660096</span>
 <span class="n">used_memory_human</span><span class="p">:</span><span class="mf">12.07</span><span class="n">M</span>
 <span class="n">used_memory_rss</span><span class="p">:</span><span class="mi">14299136</span>
 <span class="n">used_memory_peak</span><span class="p">:</span><span class="mi">15534680</span>
 <span class="n">used_memory_peak_human</span><span class="p">:</span><span class="mf">14.82</span><span class="n">M</span>
 <span class="n">used_memory_lua</span><span class="p">:</span><span class="mi">31744</span>
 <span class="n">mem_fragmentation_ratio</span><span class="p">:</span><span class="mf">1.13</span>
 <span class="n">mem_allocator</span><span class="p">:</span><span class="n">jemalloc</span><span class="o">-</span><span class="mf">3.2.0</span>
</pre></div>
</div>
<p>在上面展示的参数中，3个重要的内存统计信息的说明如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·used_memory_human :以可读格式返回Redis分配的内存总量。
·used_memory_rss :从操作系统的角度，返回Redis已分配的内存总量。这个值的结果，和top命令的输出一致。
·used_memory_peak_human :以可读格式返回Redis的内存消耗峰值。
</pre></div>
</div>
<p>如果开发者在这里的统计数据中查看到内存使用过多，在不考虑使用Redis分布式存储的情况下，开发者务必要想办法优化Redis内存的使用情况。</p>
</section>
<section id="id33">
<h3><a class="toc-backref" href="#id56">优化存储结构</a><a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p>Redis的开发者在配置文件中提供了一组参数来控制hash、list、set、sorted-set这些结构的内存存储方式。</p>
<p>在正常的情况下，hash中的value是以hashmap的方式存储，如果hashmap的成员较少，或者hashmap的值的长度较少，会以类似于线性压缩表的方式（Redis中称为ziplist）的方式保存hash的数据，该控制参数对应于Redis配置文件中的下面两项：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">hash</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">entries</span> <span class="mi">512</span>
<span class="nb">hash</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">value</span> <span class="mi">64</span>
</pre></div>
</div>
<p>·hash-max-ziplist-entries：当hashmap内部的成员不超过512时，就采用ziplist的形式存储数据；当hashmap内部的成员超过512时，就采用hashmap的形式存储数据。</p>
<p>·hash-max-ziplist-value：当hashmap内部的成员的长度不超过64时，就采用ziplist的形式存储数据；当hashmap内部的成员的长度超过64时，就采用hashmap的形式存储数据。</p>
<p>注意： 以上两个值任意一个超过了，hash的存储方式就会转换为hashmap。</p>
<p>当hash采用ziplist存储数据时，数据模型如下 <img alt="image12" src="../../_images/hash_ziplist01.png" /></p>
<p>Redis配置文件中下面这些参数的含义也是类似，分别控制list和zset是否采用ziplist的存储方式，set是否使用intset的存储方式来节省内存。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">list</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">entries</span> <span class="mi">512</span>
<span class="nb">list</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">value</span> <span class="mi">64</span>
<span class="nb">set</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">intset</span><span class="o">-</span><span class="n">entries</span> <span class="mi">512</span>
<span class="n">zset</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">entries</span> <span class="mi">128</span>
<span class="n">zset</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">value</span> <span class="mi">64</span>
</pre></div>
</div>
<p>当list采用ziplist存储数据时，数据模型如下。 <img alt="image13" src="../../_images/list_ziplist01.png" /></p>
<p>当zset采用ziplist存储数据时，数据模型如下。 <img alt="image14" src="../../_images/zipset01.png" /></p>
<p>注意： set使用了intset的结构来节省内存，intset数据模型如图</p>
<p>上面的这些参数值不是设置得越大越好，例如，hash的数据结构中如果用hashmap存储数据，查找和操作的时间复杂度都是O(1)，采用了ziplist后，由于ziplist是个线性表结构，查找和操作的时间复杂度会变成O(n)。如果数据成员量不大，则影响不大，当数据成员量变大后，则会严重影响性能。开发者需要在时间和空间之间认真衡量怎么设置上面所述的参数。
<img alt="image15" src="../../_images/redis_inset01.png" /></p>
</section>
<section id="id34">
<h3><a class="toc-backref" href="#id57">限制使用的最大内存</a><a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<p>如果Redis因为使用了过多的物理内存而导致使用交换分区后，很容易导致Redis崩溃。为了防止Redis使用过多的物理内存，可以通过配置文件中“maxmemory”的参数限制Redis使用的物理内存。</p>
<p>当Redis使用的物理内存达到了限制值，任何write操作（比如set）会触发“数据清除策略”，
通过配置文件中的“maxmemory-policy”来采用特定的“数据清除策略”，
Redis中定义的数据清除策略如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·volatile-lru：对设置了过期时间的数据，将过期的数据移除，或者按照LRU（先进先出）算法移除。如果移除后的空闲内存还不满足写入数据所需的内存空间，则提示写入异常。
·allkeys-lru：对所有的数据采用LRU（先进先出）算法。
·volatile-random:：对设置了过期时间的数据，采取“随机选取”算法移除数据。如果移除后的空闲内存还不满足写入数据所需的内存空间，则提示写入异常。
·allkeys-random：对所有的数据采取“随机选取”算法移除数据，直到空闲内存满足写入数据所需的内存空间为止。
·volatile-ttl：对设置了过期时间的数据采取TTL算法(最小存活时间) ，移除即将过期的数据。
·noeviction：不做任何干扰操作，直接返回写入异常。
</pre></div>
</div>
</section>
<section id="id35">
<h3><a class="toc-backref" href="#id58">设置过期时间</a><a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<p>Redis中可以通过下面的命令设置Key的超时时间。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">EXPIRE</span> <span class="n">key</span> <span class="n">seconds</span>
</pre></div>
</div>
<p>超过超时时间后，该Key与对应的数据会被Redis删除。通过删除过期的Key，可以在一定程度上优化内存的使用。</p>
<p>当设置了超时时间的数据被修改后，设置的超时时间会失效。</p>
<p>在Redis的每个数据库中（Redis有16个db，默认是使用db0），会使用下面的数据模型记录下所有设置了过期时间的Key和过期的时间（用时间戳表示，时间戳精确到毫秒），
如图：</p>
<p>设置了过期的Key <img alt="image16" src="../../_images/redis_timoutkey01.png" /></p>
<p>Redis用如下的步骤检查某个Key是否过期。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>（1）检查Key是否存在于设置了过期时间的Key中，如果存在，则取出过期时间。
（2）检查当前时间的时间戳是否大于Key的过期时间，如果是的话，则表示Key已过期，否则，Key未过期。
</pre></div>
</div>
<p>设置了Key的过期时间后，Redis采用下面的两种策略删除过期的Key。</p>
<p><strong>1．惰性删除</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Redis操作Key时，如果发现Key已经过期了，则删除过期的Key。

这种策略的好处是不占用过多的CPU资源，只有Redis操作Key时才检查，保证不会在其他Key上消耗CPU资源。

坏处是只有操作Key时才检查该Key是否过期，这样过期的Key的数据依然长期存储在内存中，占据内存的空间。

使用惰性删除策略时，如果内存中存在大量的过期的Key，而这些Key没有被访问过会占用大量的内存空间，操作系统无法释放内存。这种删除策略对于数据都存储于内存的Redis来说非常糟糕。

如果App后台把Redis作为一个存储系统，App业务当中肯定会存储一些冷数据，例如一些不活跃的用户数据，这些用户注册后不再打开App，就变成冷数据。这些冷数据的特点是当写入后很长时间内都不会被访问。如果只依赖于Redis的惰性删除，这部分冷数据一直占用着内存，没法清理内存空间。
</pre></div>
</div>
<p><strong>2．定期删除</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Redis为了补救惰性删除策略的不足，释放更多的内存，也对过期的Key同时采用了定期删除的策略。

定期删除策略是每隔一段时间，Redis检查所有设置了过期时间的Key，如果发现当前时间已经超过了该Key的过期时间，就把Key和对应的数据删除。为了保证Redis的高性能，Redis执行定期删除策略的频率和时长都有限制。
</pre></div>
</div>
</section>
</section>
<section id="id36">
<h2><a class="toc-backref" href="#id59"><span class="section-number">6.7.4. </span>集群</a><a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h2>
<section id="id37">
<h3><a class="toc-backref" href="#id60">1.客户端分片</a><a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h3>
<p>不推荐使用，可运维性差</p>
</section>
<section id="twemproxy">
<h3><a class="toc-backref" href="#id61">2.Twemproxy</a><a class="headerlink" href="#twemproxy" title="Permalink to this headline">¶</a></h3>
<p>Twemproxy是由Twitter开源的Redis代理，其基本原理是：Redis客户端把请求发送到Twemproxy，Twemproxy根据路由规则发送到正确的Redis实例，最后Twemproxy把结果汇集返回给客户端。</p>
<p>Twemproxy通过引入了一个代理层，将多个Redis实例进行统一管理，
使Redis客户端只需要在Twemproxy上进行操作，而不需要关心后面有多少个Redis实例，
从而实现了Redis的集群。</p>
<p>Twemproxy集群架构如图</p>
<p>Twemproxy集群架构 <img alt="image17" src="../../_images/redis_cluster01.png" /></p>
<p>Twemproxy的优点如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·客户端像连接Redis实例一样连接Twemproxy，不需要改任何的代码逻辑。
·支持无效Redis实例的自动删除。
·Twemproxy与Redis实例保持连接，减少了客户端与Redis实例的连接数。
</pre></div>
</div>
<p>Twemproxy有如下不足。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·由于Redis客户端的每个请求都经过Twemproxy代理才能到达Redis服务器，这个过程中会产生性能损失。
·没有友好的监控管理后台界面，不利于运维监控。
·最大的问题是Twemproxy无法平滑地增加Redis实例。对于运维人员来说，当因为业务需要增加Redis实例时工作量非常大。
</pre></div>
</div>
<p>wemproxy作为最被广泛使用、最久经考验、稳定性最高的Redis代理，在业界被广泛使用。</p>
</section>
<section id="codis">
<h3><a class="toc-backref" href="#id62">3.Codis</a><a class="headerlink" href="#codis" title="Permalink to this headline">¶</a></h3>
<p>Twemproxy不能平滑增加Redis实例的问题带来了很大的不便，于是豌豆荚自主研发了Codis，一个支持平滑增加Redis实例的Redis代理软件，其基于Go和C语言开发，并于2014年11月在Github上开源。</p>
<p>Codis包含下面4个部分。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·Codis Proxy：Redis客户端连接到Redis实例的代理，实现了Redis的协议，Redis客户端连接到Codis Proxy进行各种操作。Codis Proxy是无状态的，可以用Keepalived等负载均衡软件部署多个Codis Proxy实现高可用。

·CodisRedis：Codis项目维护的Redis分支，添加了slot和原子的数据迁移命令。Codis上层的Codis Proxy和Codisconfig只有与这个版本的Redis通信才能正常运行。

·Codisconfig：Codis管理工具。可以添加删除CodisRedis节点，添加删除Codis Proxy，数据迁移等操作。另外，Codisconfig自带了HTTP server，里面集成了一个管理界面，方便运维人员观察Codis集群的状态和进行相关的操作，极大提高了运维的方便性，弥补了Twemproxy的缺点。

·ZooKeeper：分布式的、开源的应用程序协调服务，是Hadoop和Hbase的重要组件，其为分布式应用提供一致性服务，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。Codis依赖于ZooKeeper存储数据路由表的信息和Codis P roxy节点的元信息。另外，Codisconfig发起的命令都会通过ZooKeeper同步到Codis P roxy的节点。
</pre></div>
</div>
<p>Codis的架构如图 <img alt="image18" src="../../_images/codis01.png" /></p>
<p>Codis引入了Redis Server G
roup，其通过指定了一个主CodisRedis和一个或多个从CodisRedis，实现了Redis集群的高可用。当一个主CodisRedis挂掉时，Codis不会自动把一个从CodisRedis提升为主CodisRedis，这涉及到数据的一致性问题（Redis本身的数据同步是采用主从异步复制，当数据在主CodisRedis写入成功时，从CodisRedis是否已读入这个数据是没法保证的），需要管理员在管理界面上手动把从CodisRedis提升为主CodisRedis。</p>
<p>如果觉得麻烦，豌豆荚也提供了一个工具Codis-ha，这个工具会在检测到主CodisRedis挂掉的时候将其下线并提升一个从CodisRedis为主CodisRedis。</p>
<p>Codis最大的优势在于支持平滑增加（减少）Redis Server
Group（Redis实例），能安全、透明地迁移数据，这也是Codis有别于Twemproxy等静态的分布式Redis解决方案的地方。</p>
</section>
<section id="redis-3-0">
<h3><a class="toc-backref" href="#id63">4.Redis 3.0集群</a><a class="headerlink" href="#redis-3-0" title="Permalink to this headline">¶</a></h3>
<p>Redis
3.0集群采用了P2P的模式，完全去中心化。Redis把所有的Key分成了16384个slot，每个Redis实例负责其中一部分slot。集群中的所有信息（节点、端口、slot等），都通过节点之间定期的数据交换而更新。</p>
<p>Redis客户端在任意一个Redis实例发出请求，如果所需数据不在该实例中，通过重定向命令引导客户端访问所需的实例。</p>
<p>Redis 3.0集群的工作流程如图 <img alt="image19" src="../../_images/redis_cluster02.png" /></p>
<p>如上图所示Redis集群内的机器定期交换数据，工作流程如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1.Redis客户端在Redis2实例上访问某个数据。
2.在Redis2内发现这个数据是在Redis3这个实例中，给Redis客户端发送一个重定向的命令。
3.Redis客户端收到重定向命令后，访问Redis3实例获取所需的数据。
</pre></div>
</div>
<p>Redis 3.0的集群方案有以下两个问题。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1.一个Redis实例具备了“数据存储”和“路由重定向”，完全去中心化的设计。这带来的好处是部署非常简单，直接部署Redis就行，不像Codis有那么多的组件和依赖。但带来的问题是很难对业务进行无痛的升级，如果哪天Redis集群出了什么严重的Bug，就只能回滚整个Redis集群。

2.对协议进行了较大的修改，对应的Redis客户端也需要升级。升级Redis客户端后谁能确保没有Bug？而且对于线上已经大规模运行的业务，升级代码中的Redis客户端也是一个很麻烦的事情。
</pre></div>
</div>
<p>综合上面所述的两个问题，Redis 3.0集群在业界并没有被大规模使用。</p>
</section>
<section id="id38">
<h3><a class="toc-backref" href="#id64">5.云服务器上的集群服务</a><a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h3>
<p>国内的云服务器提供商阿里云、UCloud等均推出了基于Redis的云存储服务。这个服务的特性如下。</p>
<section id="id39">
<h4>1．动态扩容<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>用户可以通过控制面板升级所需的Redis存储空间，扩容的过程中服务部不需要中断或停止，整个扩容过程对用户透明、无感知，这点是非常实用的，在前面介绍的方案中，解决Redis平滑扩容是个很烦琐的任务，现在按几下鼠标就能搞定，大大减少了运维的负担。
</pre></div>
</div>
</section>
<section id="id40">
<h4>2.数据多备<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>数据保存在一主一备两台机器中，其中一台机器宕机了，数据还在另外一台机器上有备份。
</pre></div>
</div>
</section>
<section id="id41">
<h4>3.自动容灾<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>主机宕机后系统能自动检测并切换到备机上，实现服务的高可用。
</pre></div>
</div>
</section>
<section id="id42">
<h4>4．实惠<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>很多情况下为了使Redis的性能更高，需要购买一台专门的服务器用于Redis的存储服务，但这样子CPU、内存等资源就浪费了，购买Redis云存储服务就很好地解决了这个问题。
</pre></div>
</div>
<p>有了Redis云存储服务，能使App后台开发人员从烦琐运维中解放出来。App后台要搭建一个高可用、高性能的Redis服务，需要投入相当的运维成本和精力。如果使用云存储服务，就没必要投入这些成本和精力，可以让App后台开发人员更专注于业务。</p>
</section>
</section>
</section>
<section id="id43">
<h2><a class="toc-backref" href="#id65"><span class="section-number">6.7.5. </span>持久化</a><a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h2>
<p>Redis是一个支持持久化操作的内存数据库，通过持久化机制把内存中的数据保存在硬盘文件。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。</p>
<p>Redis常用的持久化机制有下面两种。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>· RDB
· AOF
</pre></div>
</div>
<section id="rdb">
<h3><a class="toc-backref" href="#id66">RDB</a><a class="headerlink" href="#rdb" title="Permalink to this headline">¶</a></h3>
<p>RDB是Redis默认的持久化方式，
这种方式是按照一定的时间周期策略把内存的数据以<code class="docutils literal notranslate"><span class="pre">快照</span></code>的形式写入到硬盘的二进制文件。
<code class="docutils literal notranslate"><span class="pre">RDB默认的数据文件是dump.rdb，该数据文件能在配置文件中修改。</span></code></p>
<p>下面是Redis配置文件中有关RDB的主要参数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dbfilename</span> <span class="n">dump</span><span class="o">.</span><span class="n">rdb</span> <span class="c1">#快照的文件名</span>
<span class="nb">dir</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">redis</span><span class="o">/</span><span class="mi">6379</span> <span class="c1">#快照保存的路径</span>
<span class="n">save</span> <span class="mi">900</span> <span class="mi">1</span>              <span class="c1">#当有1 个数据被改变时，900 秒刷新到硬盘一次</span>
<span class="n">save</span> <span class="mi">300</span> <span class="mi">10</span>             <span class="c1">#当有10 个数据被改变时，300 秒刷新到硬盘一次</span>
<span class="n">save</span> <span class="mi">60</span> <span class="mi">10000</span>           <span class="c1">#当有10000 数据被改变时，60 秒刷新到硬盘一次</span>
</pre></div>
</div>
<p>执行RDB持久化的过程如图 <img alt="image20" src="../../_images/redis_rdb001.png" /></p>
<p>RDB持久化的过程如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1．根据配置文件中执行RDB的时机，Redis调用fork生成子进程，这样就有了Redis的子进程和父进程。
2．父进程继续处理客户端发送的请求，子进程把其内存的数据写入到临时文件。由于Linux操作系统的特性，父进程和子进程会共享相同的内存空间，所以子进程的数据是和fork时Redis中内存的数据一样的。
3．子进程写入临时文件完毕后，用临时文件替换RDB的数据文件，子进程退出。
</pre></div>
</div>
<p>需要注意的是，每次持久化的过程都是把Redis内存数据完整地写入到磁盘，并不是只写入修改的数据，因此，如果Redis内存数据量大，那么就会造成频繁的写入操作，可能会严重影响性能。</p>
<p>由于RDB的方式是每隔一段时间才把内存数据持久化，
如果Redis意外退出会丢失最后一次持久化后的所有数据。为了防止这个问题，
可以采用下面介绍的另外一种持久化方式—AOF。</p>
</section>
<section id="aof">
<h3><a class="toc-backref" href="#id67">AOF</a><a class="headerlink" href="#aof" title="Permalink to this headline">¶</a></h3>
<p>使用AOF的持久化方式，Redis会把每个写入命令通过write函数追加到持久化文件中（默认文件是Appendonly.aof），当Redis重启的时候会通过执行持久化文件的写命令重建内存数据。</p>
<p>由于Linux会把对文件的写入数据通过buffer缓冲，因此Linux可能不是立即写入到文件，有丢失数据的风险。在Redis的配置文件中，可以通过相应的配置选项告诉Redis需要通过fsync函数强制Linux写入到磁盘的时机。</p>
<p>下面是Redis配置文件中有关AOF持久化的主要参数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Appendonly</span> <span class="n">no</span>                    <span class="c1">#是否开启AOF 的持久化方式</span>
  <span class="n">Appendfilename</span> <span class="s2">&quot;Appendonly.aof&quot;</span>  <span class="c1">#AOF 文件的名称，默认为Appendonly.aof</span>
  <span class="c1"># Appendfsync always              #每次收到写命令就立即强制写入到磁盘，能保证完全持久化，但速度也最慢，不推荐</span>
  <span class="n">Appendfsync</span> <span class="n">everysec</span>              <span class="c1">#每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐</span>
  <span class="c1"># Appendfsync no                  #完全依赖Linux，性能最好，但持久化没保证</span>
</pre></div>
</div>
<p>用AOF的持久化方式慢慢会出现一个问题：AOF文件会变得越来越大。
例如，有一个写命令“set n um 1”，然后执行了100次写命令“incr
num”，这时num的值为101，
这100次“incr”操作都会记录到持久化文件，但重建内存数据时，
实际只需要执行“set nu m 101”就可以了，无须先执行“set num
1”再执行100次“incr num”。</p>
<p>为了压缩AOF文件，Redis提供了bgrewriteaof命令，Redis收到这个命令后会以类似创建RDB文件的方式将内存数据以命令的形式保存到临时文件中，最后替换原文件。</p>
<p>下面是Redis配置文件中有关bgrewriteaof命令的主要参数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">no</span><span class="o">-</span><span class="n">Appendfsync</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">rewrite</span> <span class="n">yes</span>     <span class="c1">#在日志重写时，不进行命令追加，而将其放在缓冲区中</span>
<span class="n">auto</span><span class="o">-</span><span class="n">aof</span><span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="n">percentage</span> <span class="mi">100</span>   <span class="c1">#当前AOF 文件大小是上次日志重写的AOF 文件大小的二倍时，自动启动新的日志重写过程。</span>
<span class="n">auto</span><span class="o">-</span><span class="n">aof</span><span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="nb">min</span><span class="o">-</span><span class="n">size</span> <span class="mi">64</span><span class="n">mb</span>    <span class="c1">#当前AOF 文件重写的最少值</span>
</pre></div>
</div>
<p>当“auto-aof-rewrite-percentage”和“auto-aof-rewrite-min-size”这两个条件都满足时，才会触发bgrewriteaof命令。</p>
<p>执行bgrewriteaof命令过程如图 <img alt="image21" src="../../_images/redis_AOF0001.png" /></p>
<p>执行bgrewriteaof命令过程如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1．Redis调用fork生成子进程，这样就有了Redis的子进程和父进程。
2．父进程继续处理客户端发送的请求，子进程把内存数据以命令的形式写入到临时文件。由于Linux操作系统的特性，父进程和子进程会共享相同的内存空间，所以子进程的数据是和fork时Redis中内存的数据一致的。
3．在子进程写临时文件的过程中，父进程把收到的写命令缓存起来。
4．子进程写入临时文件完毕，子进程通知父进程，父进程把缓存中的写入命令追加到临时文件。
5．临时文件替换AOF文件，父进程继续把新增的写命令追加到AOF文件，子进程退出。
</pre></div>
</div>
</section>
</section>
<section id="id44">
<h2><a class="toc-backref" href="#id68"><span class="section-number">6.7.6. </span>故障排除案例</a><a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h2>
<section id="id45">
<h3><a class="toc-backref" href="#id69">Redis崩溃的故障</a><a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h3>
<p><strong>故障现象</strong>： 在测试某个业务的过程中，发现Redis偶尔会崩溃。</p>
<p><strong>查找故障</strong>：
这个现象不是经常会出现，查找Redis的错误日志也没有记录什么消息。该业务写Redis的操作非常频繁，Redis占用的内存高，操作系统已经使用了Swap分区。</p>
<p><strong>原因分析</strong>：这是由于Redis的持久化文件过大引起的故障。
Redis的持久化文件过大并要对其进行读写时，操作系统把这个文件加载到物理内存中。加载持久化文件所占用的内存加上Redis本身占用的内存，操作系统会认为Redis使用了两倍的内存。这样就会造成了当如果Redis实际占用了大概一半的物理内存时，操作系统就认为内存不足，开始使用liunx的Swap分区，造成Redis不稳定甚至是崩溃。</p>
<p><strong>经验教训</strong>： 持久化操作需要合理地规划内存。</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="06.MySQL%E2%80%94App%E5%90%8E%E5%8F%B0%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.html" class="btn btn-neutral float-left" title="6.6. MySQL—App后台最常用的数据库" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="08.MongoDB%E2%80%94App%E5%90%8E%E5%8F%B0%E6%96%B0%E5%85%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.html" class="btn btn-neutral float-right" title="6.8. MongoDB—App后台新兴的数据库" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>