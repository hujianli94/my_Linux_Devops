<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. Shell脚本在Devops下的应用 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. Python在Devops与自动化运维中的应用" href="03.Python%E5%9C%A8Devops%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html" />
    <link rel="prev" title="1. Devops与自动化运维的意义" href="01.Devops%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%9A%84%E6%84%8F%E4%B9%89.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> 小健_Linux-shell-Devops_Blog
            <img src="../_static/devops_photo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">DevOps和自动化运维实践</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01.Devops%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%9A%84%E6%84%8F%E4%B9%89.html">1. Devops与自动化运维的意义</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2. Shell脚本在Devops下的应用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shell">2.1. 2.1 Shell脚本的基本元素</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">2.2. 2.2 Shell基础正则表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">2.3. 2.3 Shell特殊字符</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">2.4. 2.4 变量和运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">2.4.1. 写入环境变量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id5">2.5. 2.5 运行、调试Shell脚本</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test">2.6. 2.6 test语句</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">2.6.1. 2.6.1 文件测试运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">2.6.2. 2.6.2 字符串测试运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">2.6.3. 2.6.3 整数值测试运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">2.6.4. 2.6.4 逻辑运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id10">2.7. 2.7 Shell中的自定义函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">2.8. 2.8 Shell中的字符串截取</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">2.9. 2.9 Shell参数替换和扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">2.10. 2.10 Shell应用于Devops开发中音掌握的系统知识点</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">2.10.1. 2.10.1 Shell多进程并发</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shellshell">2.10.2. 2.10.2 Shell脚本中执行另一个Shell脚本</a></li>
<li class="toctree-l4"><a class="reference internal" href="#flock">2.10.3. 2.8.3 flock文件锁</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#parallellism">2.11. 2.10 什么是并行（parallellism）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">2.12. 2.11 什么是管道</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="03.Python%E5%9C%A8Devops%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html">3. Python在Devops与自动化运维中的应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="04.%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Shell%E8%84%9A%E6%9C%AC.html">4. 生产环境下的Shell脚本</a></li>
<li class="toctree-l2"><a class="reference internal" href="05.%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84Python%E8%84%9A%E6%9C%AC%E5%88%86%E4%BA%AB.html">5. 工作中的Python脚本分享</a></li>
<li class="toctree-l2"><a class="reference internal" href="06.%E5%88%A9%E7%94%A8Docker%E6%90%AD%E5%BB%BAJenkines-Master-Slave%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83.html">6. 利用Docker搭建Jenkines-Master-Slave分布式环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="07.GitLab%E5%9C%A8DevOps%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8.html">7. GitLab在DevOps工作中的实际应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="08.%E7%94%A8Gunicorn%E9%83%A8%E7%BD%B2%E9%AB%98%E6%80%A7%E8%83%BDPython-WSGI%E6%9C%8D%E5%8A%A1%E5%99%A8.html">8. 用Gunicorn部署高性能Python-WSGI服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="09.Supervisor%E5%9C%A8DevOps%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html">9. Supervisor在DevOps中的应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86Cerely.html">10. 分布式队列管理Cerely</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Github/index.html">Github入门到实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Jenkins/index.html">Jenkins持续化集成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../KVM/index.html">KVM实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Linux/index.html">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Mysql/index.html">Mysql王者之路</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other/index.html">Other</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Network_route_switch/index.html">Network_route_switch</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">小健_Linux-shell-Devops_Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">DevOps和自动化运维实践</a> &raquo;</li>
      <li><span class="section-number">2. </span>Shell脚本在Devops下的应用</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/DevOps/02.Shell脚本在Devops下的应用.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#shelldevops" id="id16">Shell脚本在Devops下的应用</a></p>
<ul>
<li><p><a class="reference internal" href="#shell" id="id17">2.1 Shell脚本的基本元素</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id18">2.2 Shell基础正则表达式</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id19">2.3 Shell特殊字符</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id20">2.4 变量和运算符</a></p>
<ul>
<li><p><a class="reference internal" href="#id4" id="id21">写入环境变量</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id5" id="id22">2.5 运行、调试Shell脚本</a></p></li>
<li><p><a class="reference internal" href="#test" id="id23">2.6 test语句</a></p>
<ul>
<li><p><a class="reference internal" href="#id6" id="id24">2.6.1 文件测试运算符</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id25">2.6.2 字符串测试运算符</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id26">2.6.3 整数值测试运算符</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id27">2.6.4 逻辑运算符</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id10" id="id28">2.7 Shell中的自定义函数</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id29">2.8 Shell中的字符串截取</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id30">2.9 Shell参数替换和扩展</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id31">2.10 Shell应用于Devops开发中音掌握的系统知识点</a></p>
<ul>
<li><p><a class="reference internal" href="#id14" id="id32">2.10.1 Shell多进程并发</a></p></li>
<li><p><a class="reference internal" href="#shellshell" id="id33">2.10.2 Shell脚本中执行另一个Shell脚本</a></p></li>
<li><p><a class="reference internal" href="#flock" id="id34">2.8.3 flock文件锁</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#parallellism" id="id35">2.10 什么是并行（parallellism）</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id36">2.11 什么是管道</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="shelldevops">
<h1><a class="toc-backref" href="#id16"><span class="section-number">2. </span>Shell脚本在Devops下的应用</a><a class="headerlink" href="#shelldevops" title="Permalink to this headline">¶</a></h1>
<p>Shell脚本成为运维开发人员的“瑞士军刀”。所以不管是系统管理员，还是运维开发人员或者开发人员，掌握Shell脚本语言，对我们的工作能够起到很大的帮助作用。</p>
<section id="shell">
<h2><a class="toc-backref" href="#id17"><span class="section-number">2.1. </span>2.1 Shell脚本的基本元素</a><a class="headerlink" href="#shell" title="Permalink to this headline">¶</a></h2>
<p>单行注释</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash     //第一行</span>
<span class="c1">#               // 表示单行注释</span>
</pre></div>
</div>
<p>多行注释</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>:<span class="s">&lt;&lt;BLOCK</span>
<span class="s">中间部分为要省略的内容</span>
<span class="s">BLOCK</span>
</pre></div>
</div>
<p>Shell脚本文件的命令解释程序</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#! /bin/bash</span>
</pre></div>
</div>
</section>
<section id="id1">
<h2><a class="toc-backref" href="#id18"><span class="section-number">2.2. </span>2.2 Shell基础正则表达式</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>参考玩转shell脚本编程的 `正则表达式章节</p>
<p><a class="reference external" href="https://www.jb51.net/tools/shell_regex.html">Shell中的正则表达式</a></p>
</section>
<section id="id2">
<h2><a class="toc-backref" href="#id19"><span class="section-number">2.3. </span>2.3 Shell特殊字符</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p><img alt="image0" src="../_images/shell-teshustr.PNG" /></p>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id20"><span class="section-number">2.4. </span>2.4 变量和运算符</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">变量名</span><span class="o">=</span>“变量”
<span class="nb">readonly</span> <span class="nv">变量名</span><span class="o">=</span>“变量”       <span class="c1">#设置只读变量</span>
<span class="nb">echo</span> $变量名
<span class="nb">set</span>         <span class="c1">#显示本地所有的变量</span>
<span class="nb">unset</span>       <span class="c1">#变量名清除变量</span>
<span class="nb">readonly</span>    <span class="c1">#显示当前Shell下有哪些只读变量</span>
</pre></div>
</div>
<p>设置环境变量，环境变量可以用于所有的子shell中，其包括编辑器、脚本和应用。</p>
<p>环境变量的主目标如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">$HOME</span>/.bash_profile<span class="o">(</span>/etc/profile<span class="o">)</span>
</pre></div>
</div>
<p>设置环境变量，例句如下：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">test</span><span class="o">=</span><span class="s2">&quot;123&quot;</span>
</pre></div>
</div>
<p>查看环境变量，命令如下：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>env
</pre></div>
</div>
<p>或者使用</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span>
</pre></div>
</div>
<p>变量清除命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unset</span> <span class="n">变量名</span>
</pre></div>
</div>
<p><strong>内部变量</strong></p>
<p>Shell提供了丰富的内部变量，为用户的Shell编程提供支持，具体如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>❑ PWD：表示当前的工作目录，其变量值等同于pwd内部命令的输出。
❑ RANDOM：每次引用这个变量时，将会生成一个均匀分布的0～32767范围内的随机整数。
❑ SCONDS：脚本已经运行的时间（秒）。
❑ PPID：当前进程的父进程的进程ID。
❑ $? ：表示最近一次执行的命令或Shell脚本的出口状态。
</pre></div>
</div>
<p><strong>环境变量</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Shell提供的主要环境变量如下所示。
❑ EDITOR：用于确定命令行编辑所用的编辑程序，通常为vim。
❑ HOME：用户主目录。
❑ PATH：指定命令的检索路径。
</pre></div>
</div>
<section id="id4">
<h3><a class="toc-backref" href="#id21"><span class="section-number">2.4.1. </span>写入环境变量</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>例如，要将/usr/local/mysql/bin目录添加进系统默读的PATH变量中</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/local/mysql/bin
<span class="nb">export</span> PATH
<span class="nb">echo</span> <span class="nv">$PATH</span>
</pre></div>
</div>
<p>Linux中含有两个重要的文件，</p>
<p><code class="docutils literal notranslate"><span class="pre">/etc/profile</span></code>和<code class="docutils literal notranslate"><span class="pre">$HOME/.bash_profile</span></code>，每当系统登录时都要读取这两个文件，用来初始化系统所用到的变量，其中<code class="docutils literal notranslate"><span class="pre">/etc/profile</span></code>是超级用户所用，</p>
<p><code class="docutils literal notranslate"><span class="pre">$HOME/.bash_profile</span></code>是每个用户自己独立的，可以通过修改该文件来设置PATH变量。</p>
<p>注意</p>
<p><code class="docutils literal notranslate"><span class="pre">这种方法也只能使当前用户生效，而并非所有用户。</span></code></p>
<p>如果要让所有用户都能够用到此PATH变量，则可以用vim命令打开“/etc/profile”文件，在适当位置添加“PATH=$PATH:/usr/local/mysql/bin”，然后执行“source
/etc/profile”使其生效。</p>
<p><strong>位置变量的用法</strong></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env bash</span>
<span class="nb">echo</span> <span class="s2">&quot;第1个参数为：&quot;</span> <span class="nv">$0</span>
<span class="nb">echo</span> <span class="s2">&quot;第2个参数为：&quot;</span> <span class="nv">$1</span>
<span class="nb">echo</span> <span class="s2">&quot;第3个参数为：&quot;</span> <span class="nv">$2</span>
<span class="nb">echo</span> <span class="s2">&quot;第4个参数为：&quot;</span> <span class="nv">$3</span>
<span class="nb">echo</span> <span class="s2">&quot;第5个参数为：&quot;</span> <span class="nv">$4</span>
</pre></div>
</div>
<p>执行结果如下:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./aaa.sh <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>
第1个参数为： ./aaa.sh
第2个参数为： <span class="m">1</span>
第3个参数为： <span class="m">2</span>
第4个参数为： <span class="m">3</span>
第5个参数为： <span class="m">4</span>
</pre></div>
</div>
<p>从第10个参数开始就要使用花括号将编号括起来，如“${10}”。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>表示方法</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>$n</p></td>
<td><p>$1 表示第一个参数，$2 表示第二个参数 …</p></td>
</tr>
<tr class="row-odd"><td><p>$#</p></td>
<td><p>命令行参数的个数</p></td>
</tr>
<tr class="row-even"><td><p>$0</p></td>
<td><p>当前程序的名称</p></td>
</tr>
<tr class="row-odd"><td><p>$?</p></td>
<td><p>前一个命令或函数的返回码</p></td>
</tr>
<tr class="row-even"><td><p>$*</p></td>
<td><p>以“参数1 参数2 …” 形式保存所有参数</p></td>
</tr>
<tr class="row-odd"><td><p>$&#64;</p></td>
<td><p>以“参数1”“参数2” … 形式保存所有参数</p></td>
</tr>
<tr class="row-even"><td><p>$$</p></td>
<td><p>本程序的(进程ID号)PID</p></td>
</tr>
<tr class="row-odd"><td><p>$_</p></td>
<td><p>表示上一个命令的最后一个参数</p></td>
</tr>
<tr class="row-even"><td><p>$!</p></td>
<td><p>表示最后执行的后台命令的PID</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">$*</span></code>和<code class="docutils literal notranslate"><span class="pre">$&#64;</span></code>都是表示所有的位置参数，但是区别如下：</p>
<p><strong>相同点</strong>：都是引用所有参数。 <strong>不同点</strong>：只有在双引号中体现出来。</p>
<p>假设在脚本运行时写了三个参数 1、2、3</p>
<p><code class="docutils literal notranslate"><span class="pre">$*</span> <span class="pre">等价于</span> <span class="pre">“1</span> <span class="pre">2</span> <span class="pre">3”（传递了一个参数）</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">而$&#64;等价于</span> <span class="pre">“1”</span> <span class="pre">“2”</span> <span class="pre">“3”（传递了三个参数）</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">$#命令行参数的个数</span></code></p>
<p><strong>关于位置参数shift的常见用法</strong></p>
<p>例如，脚本publishconf依次对后面的IP进行操作，代码如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>./publishconf -p <span class="m">192</span>.168.11.2 <span class="m">192</span>.168.11.3 <span class="m">192</span>.168.11.4 <span class="m">192</span>.168.11.5 <span class="m">192</span>.168.11.6
</pre></div>
</div>
<p>部分代码不如</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env bash</span>
<span class="c1">#usage:xxx</span>
<span class="c1">#scripts_name:${NAME}.sh</span>
<span class="c1"># author：xiaojian</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$#</span><span class="s2">&quot;</span> &gt;<span class="o">=</span><span class="m">3</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">shift</span> <span class="m">1</span>
<span class="c1">#    echo &quot;此次需要更新的机器IP为$@&quot;</span>
    <span class="k">for</span> flat <span class="k">in</span> <span class="nv">$@</span> <span class="p">;</span> <span class="k">do</span>
           <span class="nb">echo</span> <span class="s2">&quot;此次需要更新的机器IP为</span><span class="nv">$flat</span><span class="s2">&quot;</span>
           <span class="c1"># 操作动作</span>
    <span class="k">done</span>
<span class="k">fi</span>
</pre></div>
</div>
</section>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id22"><span class="section-number">2.5. </span>2.5 运行、调试Shell脚本</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>调试Shell脚本</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>· -n: 不会执行该脚本，仅查询脚本语法是否有问题，并给出错误提示。
· -v：在执行脚本时，先将脚本的内容输出到屏幕上，然后执行脚本。如果有错误，也会给出错误提示。
· -x:  将执行的脚本内容输出显示到屏幕上，这是对调试很有用的参数。
</pre></div>
</div>
<p>参数-x是追踪脚本执行过程的一种非常好的方法，其可以在执行前列出所执行的所有程序段。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bash -x 调试Shell脚本，bash会先打印出每行脚本，再打印出每行脚本的执行结果，如果只调试其中几行脚本，
可以采用“set -x”和“set +x”把要测试的部分包含进来。示例代码如下：

set -x
脚本部分内容
set +x
</pre></div>
</div>
<p>set命令最大的优点是：</p>
<p>与“bash -x”相比，“set
-x”可以缩小调试的作用域，这个功能在工作中是非常有用的功能，可以帮助我们调试变量，找出Bug的位置并打印。</p>
<p><strong>退出或出口状态</strong></p>
<p>在Shell脚本中，可以利用<code class="docutils literal notranslate"><span class="pre">&quot;exit[n]&quot;</span></code>
n在0~255范围之内。向脚本的父进程返回一个数值为n的shell脚本出口状态。</p>
<p>如果Shell脚本是以不带参数的exit语句结束的，则Shell脚本的出口状态就是脚本最后一条命令的出口状态。</p>
<p>在Unix中，为了测试一个命令或Shell脚本的执行结果，<code class="docutils literal notranslate"><span class="pre">&quot;$?&quot;</span></code>内部变量将返回执行执行的最后一条命令的出口状态。其中0位正确值，其他非零为错误值。</p>
</section>
<section id="test">
<h2><a class="toc-backref" href="#id23"><span class="section-number">2.6. </span>2.6 test语句</a><a class="headerlink" href="#test" title="Permalink to this headline">¶</a></h2>
<section id="id6">
<h3><a class="toc-backref" href="#id24"><span class="section-number">2.6.1. </span>2.6.1 文件测试运算符</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>下面是文件属性测试表达式。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>❑ -e file：如果给定的文件存在，则条件测试的结果为真。

❑ -r file：如果给定的文件存在，且其访问权限是当前用户可读的，则条件测试的结果为真。

❑ -w file：如果给定的文件存在，且其访问权限是当前用户可写的，则条件测试的结果为真。

❑ -x file：如果给定的文件存在，且其访问权限是当前用户可执行的，则条件测试的结果为真。

❑ -s file：如果给定的文件存在，且其大小大于0，则条件测试的结果为真。

❑ -f file：如果给定的文件存在，且是一个普通文件，则条件测试的结果为真。

❑ -d file：如果给定的文件存在，且是一个目录，则条件测试的结果为真。

❑ -L file：如果给定的文件存在，且是一个符号链接文件，则条件测试的结果为真（注意：此处的L为大写）。

❑ -c file：如果给定的文件存在，且是字符特殊文件，则条件测试的结果为真。

❑ -b file：如果给定的文件存在，且是块特殊文件，则条件测试的结果为真。

❑ -p file：如果给定的文件存在，且是命名的管道文件，则条件测试的结果为真。
</pre></div>
</div>
<p>文件测试运算符常见代码举例如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">BACKDIR</span><span class="o">=</span>/data/backup

<span class="o">[</span> -d <span class="si">${</span><span class="nv">BACKDIR</span><span class="si">}</span> <span class="o">]</span> <span class="o">||</span> mkdir -p <span class="si">${</span><span class="nv">BACKDIR</span><span class="si">}</span>
<span class="o">[</span> -d <span class="si">${</span><span class="nv">BACKDIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">DATE</span><span class="si">}</span> <span class="o">]</span> <span class="o">||</span> mkdir -p <span class="si">${</span><span class="nv">BACKDIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">DATE</span><span class="si">}</span>
<span class="o">[</span> ! -d <span class="si">${</span><span class="nv">BACKDIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">OLDDATE</span><span class="si">}</span> <span class="o">]</span> <span class="o">||</span> rm -rf <span class="si">${</span><span class="nv">BACKDIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">OLDDATE</span><span class="si">}</span>
</pre></div>
</div>
</section>
<section id="id7">
<h3><a class="toc-backref" href="#id25"><span class="section-number">2.6.2. </span>2.6.2 字符串测试运算符</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>❑ -z str：如果给定的字符串的长度为0，则条件测试的结果为真。
❑ -n str：如果给定的字符串的长度大于0，则条件测试的结果为真。要求字符串必须加引号。
❑ s1=s2：如果给定的字符串s1等同于字符串s2，则条件测试的结果为真。
❑ s1! =s2：如果给定的字符串s1不等同于字符串s2，则条件测试的结果为真。
❑ s1&lt;s2，如果给定的字符串s1小于字符串s2，则条件测试的结果为真。例如：if[[ &quot;$a&quot;&lt;&quot;Sb&quot; ]]注意，if[ &quot;$a&quot;/&lt;&quot;$b&quot;]，在单方括号情况下，字符“&lt;”和“&gt;”前须必加转义符号“\”。

❑ s1&gt;s2：若给定的字符串s1大于字符串s2，则条件测试的结果为真。
</pre></div>
</div>
<p>在比较字符串的test语句中，变量或字符串表达式的前后一定要加双引号。</p>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id26"><span class="section-number">2.6.3. </span>2.6.3 整数值测试运算符</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>整数测试表达式为</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>“-eq”（等于）
“-ne”（不等于)
“-gt”（大于）
“-lt”（小于）
“-ge”（大于等于）
“-le”（小于等于）
</pre></div>
</div>
</section>
<section id="id9">
<h3><a class="toc-backref" href="#id27"><span class="section-number">2.6.4. </span>2.6.4 逻辑运算符</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>Shell中的逻辑运算符，具体说明如下所示。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>❑ (expression)：用于计算括号中的组合表达式，如果整个表达式的计算结果都为真，则测试结果也为真。

❑! exp：可对表达式进行逻辑非运算，即对测试结果求反。例如“test ! -ffile1”。

❑ 符号-a或&amp;&amp;：表示逻辑与运算。

❑ 符号-o或||：表示逻辑或运算。
</pre></div>
</div>
</section>
</section>
<section id="id10">
<h2><a class="toc-backref" href="#id28"><span class="section-number">2.7. </span>2.7 Shell中的自定义函数</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>自定义语法比较简单，语法结构如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> 函数名<span class="o">()</span> <span class="o">{</span>
    action<span class="p">;</span>
    <span class="o">[</span><span class="k">return</span> 数值<span class="p">;</span><span class="o">]</span>
<span class="o">}</span>
</pre></div>
</div>
<p>❑
自定义函数既可以带function函数名()定义，也可以直接用函数名()定义，不带任何参数。</p>
<p>❑
参数返回时，可以显式加return返回；如果不加，则将以最后一条命令的运行结果作为返回值。return后跟数值，取值范围为0～255。</p>
<p>Shell不像Python及Go语言，其没有OOP的概念，因此Shell肯定也是没有Class（类）的，所以我们若想以Class的方式来封装多个Shell函数，那是不可能实现的。但是我们在编写Shell需求工作时会有一种很常见的需求.</p>
<p>现在为了减少代码复用，各业务功能需求就是多个函数的组合，具体应该怎么实现呢？这里其实可以结合case语句来实现。</p>
<p>脚本名称为<code class="docutils literal notranslate"><span class="pre">automanage.sh</span></code>。部分内容如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>--mirror-interac<span class="o">)</span>
    rg_Checkrelease
    rg_RebootCheck <span class="o">&amp;&amp;</span> rg_BasicCheck <span class="o">&amp;&amp;</span> rg_InitBasic <span class="o">&amp;&amp;</span> rg_mkpart <span class="o">&amp;&amp;</span> rg_mkfs_inerac <span class="o">&amp;&amp;</span> rg_info <span class="m">0</span> <span class="s1">&#39;完成&#39;</span>
</pre></div>
</div>
<p>事实上我们执行以下命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">automanage</span><span class="o">.</span><span class="n">sh</span> <span class="o">--</span><span class="n">mirror</span><span class="o">-</span><span class="n">interac</span>
</pre></div>
</div>
<p>此命令会依次调用rg_ChkRelease()、rg_RebootCheck()、rg_BasicCheck()、rg_InitBasic()、rg_mkpart()、rg_mkfs_interac()及rg
info一系列函数，实现工作需求。</p>
</section>
<section id="id11">
<h2><a class="toc-backref" href="#id29"><span class="section-number">2.8. </span>2.8 Shell中的字符串截取</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>| Expression                                | Meaning                                                      |
| ----------------------------------------- | ------------------------------------------------------------ |
| ${#string}                              | $string 的长度                                               |
|                                           |                                                              |
| ${string:position}                   | 在 $string 中, 从位置 $position 开始提取子串                 |
| ${string:position:length}               | 在 $string 中, 从位置 $position 开始提取长度为 $length 的&lt;br/&gt;子串 |
|                                           |                                                              |
| ${string#substring}                        | 从变量 $string 的开头, 删除最短匹配 $substring 的子串        |
| ${string##substring}                      | 从变量 $string 的开头, 删除最长匹配 $substring 的子串        |
| ${string%substring}                       | 从变量 $string 的结尾, 删除最短匹配 $substring 的子串        |
| ${string%%substring}                    | 从变量 $string 的结尾, 删除最长匹配 $substring 的子串        |
|                                           |                                                              |
| ${string/substring/replacement}         | 使用 $replacement , 来代替第一个匹配的 $substring            |
| ${string//substring/replacement}        | 使用 $replacement , 代替 所有 匹配的 $substring              |
| ${string/#substring/replacement}        | 如果 $string 的 前缀 匹配 $substring , 那么就&lt;br/&gt;用 $replacement 来代替匹配到的 $substring |
| ${string/%substring/replacement}        | 如果 $string 的 后缀 匹配 $substring , 那么就&lt;br/&gt;用 $replacement 来代替匹配到的 $substring |
|                                           |                                                              |
| expr match &quot;$string&quot; &#39;$substring&#39;          | 匹配 $string 开头的 $substring *的长度                       |
| expr &quot;$string&quot; : &#39;$substring&#39;                   | 匹配 $string 开头的 $substring *的长度                       |
| expr index &quot;$string&quot; $substring             | 在 $string 中匹配到的 $substring 的第一个字符出现的位置      |
| expr substr $string $position $length   | 在 $string 中从位置 $position 开始提取长度为 $length 的子&lt;br/&gt;串 |
| expr match &quot;$string&quot; &#39;\($substring\)&#39;     | 从 $string 的开头位置提取 $substring *                       |
| expr &quot;$string&quot; : &#39;\($substring\)&#39;              | 从 $string 的开头位置提取 $substring *                       |
| expr match &quot;$string&quot; &#39;.*\($substring\)&#39;  | 从 $string 的结尾提取 $substring *                           |
| expr &quot;$string&quot; : &#39;.*\($substring\)&#39;           |                                                              |
</pre></div>
</div>
</section>
<section id="id12">
<h2><a class="toc-backref" href="#id30"><span class="section-number">2.9. </span>2.9 Shell参数替换和扩展</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>| Expression        | Meaning                                                      |
| ----------------- | ------------------------------------------------------------ |
| ${var}          | 变量 var 的值, 与 $var 相同                                  |
|                   |                                                              |
| ${var-DEFAULT}  | 如果 var 没有被声明, 那么就以 $DEFAULT 作为其值 *            |
| ${var:-DEFAULT} | 如果 var 没有被声明, 或者其值为空, 那么就以 $DEFAULT 作为其值 * |
|                   |                                                              |
| ${var=DEFAULT}  | 如果 var 没有被声明, 那么就以 $DEFAULT 作为其值 *            |
| ${var:=DEFAULT} | 如果 var 没有被声明, 或者其值为空, 那么就以 $DEFAULT 作为其值 * |
|                   |                                                              |
| ${var+OTHER}    | 如果 var 声明了, 那么其值就是 $OTHER , 否则就为null字符串    |
| ${var:+OTHER}   | 如果 var 被设置了, 那么其值就是 $OTHER , 否则就为null字符串  |
|                   |                                                              |
| ${var?ERR_MSG}  | 如果 var 没被声明, 那么就打印 $ERR_MSG *                     |
| ${var:?ERR_MSG}  | 如果 var 没被设置, 那么就打印 $ERR_MSG *                     |
|                   |                                                              |
| ${!varprefix*}  | 匹配之前所有以 varprefix 开头进行声明的变量                  |
| ${!varprefix@}  | 匹配之前所有以 varprefix 开头进行声明的变量                  |
</pre></div>
</div>
</section>
<section id="id13">
<h2><a class="toc-backref" href="#id31"><span class="section-number">2.10. </span>2.10 Shell应用于Devops开发中音掌握的系统知识点</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<section id="id14">
<h3><a class="toc-backref" href="#id32"><span class="section-number">2.10.1. </span>2.10.1 Shell多进程并发</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>1）进程。若采用这种方法，则每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，因此要想与其他流进行通信，控制流必须使用进程间通信（IPC）。</p>
<p>2）I/O多路复用。若采用这种形式的并发，则应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模拟为“状态机”，数据到达文件描述符之后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享一个地址空间。</p>
<p>3）线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。线程可以看作是进程和I/O多路复用的合体，像进程一样由内核调度，像I/O多路复用一样共享一个虚拟地址空间。</p>
<p>默认情况下，Shell脚本中的命令是串行执行的，必须等到前一条命令执行完毕之后才执行接下来的命令，
但是如果有一大批的命令需要执行，而且相互之间没有影响的情况下，此时就要使用命令的并发执行了。</p>
<p>正常的程序<code class="docutils literal notranslate"><span class="pre">echo_hello.sh</span></code>代码如下所示：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env bash</span>
<span class="c1">#usage:xxx</span>
<span class="c1">#scripts_name:${NAME}.sh</span>
<span class="c1"># author：xiaojian</span>
<span class="k">for</span> <span class="o">((</span> <span class="nv">VAR</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> VAR &lt; <span class="m">5</span><span class="p">;</span> VAR++ <span class="o">))</span><span class="p">;</span> <span class="k">do</span>
    <span class="o">{</span>
    sleep <span class="m">3</span>
    <span class="nb">echo</span> <span class="s2">&quot;hello,world&quot;</span> &gt;&gt; aa <span class="p">&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;done!&quot;</span>
    <span class="o">}</span>
<span class="k">done</span>

cat aa <span class="p">|</span>wc -l
rm aa
</pre></div>
</div>
<p>使用time计算脚本的执行时间，命令结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ time sh echo_hello.sh
done!
done!
done!
done!
done!
5

real    0m18.873s
user    0m0.091s
sys     0m0.214s
</pre></div>
</div>
<p>并发执行的代码如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env bash</span>
<span class="c1">#usage:xxx</span>
<span class="c1">#scripts_name:${NAME}.sh</span>
<span class="c1"># author：xiaojian</span>
<span class="k">for</span> <span class="o">((</span> <span class="nv">VAR</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> VAR &lt; <span class="m">5</span><span class="p">;</span> VAR++ <span class="o">))</span><span class="p">;</span> <span class="k">do</span>
    <span class="o">{</span>
    sleep <span class="m">3</span>
    <span class="nb">echo</span> <span class="s2">&quot;hello,world&quot;</span> &gt;&gt; aa <span class="p">&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;done!&quot;</span>
    <span class="o">}</span> <span class="p">&amp;</span>
<span class="k">done</span>
<span class="c1"># wait 命令有一个很重要的用途就是在Shell的并发编程中，可以在Shell脚本中启动多个后台进程（使用“&amp;”），然后调用wait命令，等待所有后台进程都运行完毕，</span>
<span class="c1"># shell脚本再继续向下执行，</span>
<span class="nb">wait</span>
cat aa <span class="p">|</span>wc -l
rm aa
</pre></div>
</div>
<p>使用time计算脚本执行时间，如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">time</span> sh echo_hello2.sh
<span class="k">done</span>!
<span class="k">done</span>!
<span class="k">done</span>!
<span class="k">done</span>!
<span class="k">done</span>!
<span class="m">5</span>

real    0m5.689s
user    0m0.062s
sys     0m0.244s
</pre></div>
</div>
<p>当多个进程可能会对同样的数据执行操作时，这些进程需要保证其他进程没有在操作，
以免损坏数据，通常，这样的进程会使用一个“锁文件”，也就是创建一个文件告诉别的进程之间在运行，
如果检测到这个文件存在，就认为操作同样数据的进程在工作。这样做有个问题，当进程不小心意外死亡了，没有清理掉那个文件，
只能由用户手工的去清理了。</p>
</section>
<section id="shellshell">
<h3><a class="toc-backref" href="#id33"><span class="section-number">2.10.2. </span>2.10.2 Shell脚本中执行另一个Shell脚本</a><a class="headerlink" href="#shellshell" title="Permalink to this headline">¶</a></h3>
<p>在运行Shell脚本的时候，可采用下面两种方式来调用外部的脚本，即exec方式和source方式。</p>
<p>（1）exec方式</p>
<blockquote>
<div><p>使用exec方式来调用脚本，被执行的脚本会继承当前Shell的环境变量。但事实上，exec产生了新的进程，<strong>其会占用主Shell的进程资源并替换脚本内容</strong>，继承原主Shell的PID号，即原主Shell剩下的内容不会再执行。</p>
</div></blockquote>
<p>（2）source方式</p>
<blockquote>
<div><p>使用source或者“.”来调用外部脚本，不会产生新的进程继承当前Shell环境变量，而且被调用的脚本运行结束之后，<strong>它所拥有的环境变量和声明变量会被当前Shell保留，这点类似于将调用脚本的内容复制过来直接执行，执行完毕后原主Shell将继续运行。</strong></p>
</div></blockquote>
<p>（3）fork方式</p>
<blockquote>
<div><p>直接运行脚本，会以当前shell为父进程，产生新的进程，并且继承主脚本的环境变量和声明变量。执行完毕后，主脚本不会保留其环境变量和声明变量。</p>
</div></blockquote>
<p>总结：这样来看fork最灵活，source次之，exec最诡异。</p>
<p><em>工作中推荐使用source的方式来调用外部的Shell脚本</em>，该方式稳定性高，不会出现一些诡异的问题和bug，从而影响主程序的业务逻辑（大家也可以参考下Linux系统中的Shell脚本，如/etc/init.d/network等，基本上采用的都是这种处理方式）。</p>
</section>
<section id="flock">
<h3><a class="toc-backref" href="#id34"><span class="section-number">2.10.3. </span>2.8.3 flock文件锁</a><a class="headerlink" href="#flock" title="Permalink to this headline">¶</a></h3>
<p>Linux中的例行性工作排程Crontab会定时执行一些脚本，但脚本的执行时间往往会无法控制，若脚本执行时间过长，则可能会导致上一次任务的脚本还没执行完毕，下一次任务的脚本又开始执行了。这种情况下可能会出现一些并发问题，严重时还会导致出现脏数据、性能瓶颈的恶性循环。</p>
<p>使用flock建立排它锁可以规避这个问题，如果一个进程对某个任务加持了独占锁（排他锁），则其他进程会无法加锁，可以选择等待超时或马上返回。</p>
<p>脚本<code class="docutils literal notranslate"><span class="pre">file_lock.sh</span></code>的内容如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">&quot;----------------------------------&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;start at </span><span class="k">$(</span>date <span class="s2">&quot;+%Y-%m-%d %H:%M:%S&quot;</span><span class="k">)</span><span class="s2">....&quot;</span>
sleep 100s
<span class="nb">echo</span> <span class="s2">&quot;finished at </span><span class="k">$(</span>date <span class="s2">&quot;+%Y-%m-%d %H:%M:%S&quot;</span><span class="k">)</span><span class="s2">....&quot;</span>
</pre></div>
</div>
<p>每隔一分钟执行一次该脚本，并将输出信息写入到/tmp/test_tmp.log，下面简单介绍下flock在这里用到的选项，具体如下所示。</p>
<p>❑ -x, –exclusive：获得一个独占锁。</p>
<p>❑ -n, –nonblock：如果没有立即获得锁，则直接失败而不是等待。</p>
<p>❑ -c, –command：在Shell中运行一个单独的命令。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@localhost home<span class="o">]</span><span class="c1"># crontab -l</span>
*/1  * * * * flock -xn /dev/shm/test.lock -c <span class="s2">&quot;sh /home/file_lock.sh &gt;&gt; /tmptest_tmp.log&quot;</span>
</pre></div>
</div>
<p>输出日志如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>tail -f /tmptest_tmp.log  -f
----------------------------------
start at <span class="m">2020</span>-06-10 <span class="m">13</span>:26:01....
finished at <span class="m">2020</span>-06-10 <span class="m">13</span>:28:21....
----------------------------------
start at <span class="m">2020</span>-06-10 <span class="m">13</span>:29:01....
finished at <span class="m">2020</span>-06-10 <span class="m">13</span>:30:41....
</pre></div>
</div>
</section>
</section>
<section id="parallellism">
<h2><a class="toc-backref" href="#id35"><span class="section-number">2.11. </span>2.10 什么是并行（parallellism）</a><a class="headerlink" href="#parallellism" title="Permalink to this headline">¶</a></h2>
<p>目前大部分语言都能瞒住并发执行，当多核CPU出现后，多CPU的场景下开始产生并行的概念。</p>
<p>（1）总体概念</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在单CPU系统中，系统调度在某一时刻只能让一个线程运行，虽然这种调试机制具有多种形式（大多数是以时间片轮询为主），
但无论如何，需要通过不断切换需要运行的线程让其运行的方式就称为并发(concurrent)。

在多CPU系统中，可以让两个以上的线程同时运行，这种可以让两个以上的线程同时运行的方式称为并行(parallel)。
</pre></div>
</div>
<p>CPU到了多核时代，那么就出现了新的概念：并行。</p>
<p>并行是真正细粒度上的同时进行，即同一时间点上同时发生着多个并发；更加确切并且简单地讲就是，每个CPU上运行一个程序，以达到同一时间点上各个CPU上均在运行一个程序。</p>
<p><strong>并行和并发的具体区别</strong></p>
<p>1）并行是指两个或者多个事件在同一时刻发生，而并发是指两个或多个事件在同一时间间隔发生。</p>
<p>2）并行是在不同实体上的多个事件，而并发是在同一实体上的多个事件。</p>
<p>3）在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。</p>
</section>
<section id="id15">
<h2><a class="toc-backref" href="#id36"><span class="section-number">2.12. </span>2.11 什么是管道</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>管道的特点：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1）管道是半双工的，数据只能向一个方向流动；双方需要进行通信时，需要建立起两个管道。

2）只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。

3）单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存之中。

4）数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。
</pre></div>
</div>
<p>示例代码</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">echo</span> <span class="s2">&quot;hello&quot;</span><span class="o">|</span> <span class="n">cat</span>
</pre></div>
</div>
<p>需要注意以下几点。</p>
<p>1）管道命令只处理前一个命令的正确输出，不处理错误输出。</p>
<p>2）管道右边的命令，必须能够接收标准输入流命令才行。</p>
<p>3）管道触发两个子进程执行“|”两边的程序。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="01.Devops%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%9A%84%E6%84%8F%E4%B9%89.html" class="btn btn-neutral float-left" title="1. Devops与自动化运维的意义" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="03.Python%E5%9C%A8Devops%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html" class="btn btn-neutral float-right" title="3. Python在Devops与自动化运维中的应用" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>